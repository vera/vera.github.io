<!DOCTYPE html>
<html lang="en">
  <head>
		<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" type="text/css" href="style.css">
    <title>Vera Clemens | Master's Thesis | Software Updates for the Internet of Things</title>
  </head>
  <body>
    <main id="wrapper">
    	<div id="titlepage-triangle"></div>
    	<div id="titlepage-triangle-text">
    		<a href="https://github.com/vera/vera.github.io" target="_blank">
    		Find this page on<br/>
    		<img src="img/github-logo.svg" alt="GitHub"/></a>
    	</div>
      <header id="titlepage">
        <div>
          <h1 id="title">Software Updates for the Internet of Things</h1>
          <p id="subtitle">An Extension and Evaluation of the SUIT Implementation in RIOT</p>
        </div>
        <p id="thesis-type">Master's Thesis</p>
        <p id="author">Vera Clemens</p>
        <div>
          <p id="supervisors">
            Supervisor: Prof. Dr. rer. nat. Mesut Güneş<br/>
            Assisting Supervisor: M.Sc. Marian Buschsieweke
          </p>
          <hr>
          <p id="institution">Institute for Intelligent Cooperating Systems, Otto von Guericke University Magdeburg</p>
        </div>
        <p>July 01, 2021</p>
      </header>

    	<nav id="nav">
  			<div id="prev-section-link">
  				<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="22px" height="18px" viewBox="-0.5 -0.5 22 18"><defs/>
  					<g>
  						<path d="M 1 6 L 11 1" fill="none" stroke="rgb(68,85,255)" stroke-width="2" stroke-miterlimit="10" pointer-events="none" class="section-arrow1" />
  						<path d="M 10.1 1 L 20.1 6" fill="none" stroke="rgb(68,85,255)" stroke-width="2" stroke-miterlimit="10" pointer-events="none" class="section-arrow1" />
  						<path d="M 1 11 L 11 6" fill="none" stroke="rgb(68,85,255)" stroke-width="2" stroke-miterlimit="10" pointer-events="none" class="section-arrow2" />
  						<path d="M 10.1 6 L 20.1 11" fill="none" stroke="rgb(68,85,255)" stroke-width="2" stroke-miterlimit="10" pointer-events="none" class="section-arrow2" />
  						<path d="M 1 16 L 11 11" fill="none" stroke="rgb(68,85,255)" stroke-width="2" stroke-miterlimit="10" pointer-events="none" class="section-arrow3" />
  						<path d="M 10.1 11 L 20.1 16" fill="none" stroke="rgb(68,85,255)" stroke-width="2" stroke-miterlimit="10" pointer-events="none" class="section-arrow3" />
  					</g>
  				</svg>
  				<span>Swipe for prev. section</span>
				</div>
  			<a href="#toc" id="toc-link">Jump to ToC</a>
  			<div id="next-section-link">
  				<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="22px" height="18px" viewBox="-0.5 -0.5 22 18"><defs/>
  					<g>
  						<path d="M 1 1 L 11 6" fill="none" stroke="rgb(68,85,255)" stroke-width="2" stroke-miterlimit="10" pointer-events="none" class="section-arrow3" />
  						<path d="M 10.1 6 L 20.1 1" fill="none" stroke="rgb(68,85,255)" stroke-width="2" stroke-miterlimit="10" pointer-events="none" class="section-arrow3" />
  						<path d="M 1 6 L 11 11" fill="none" stroke="rgb(68,85,255)" stroke-width="2" stroke-miterlimit="10" pointer-events="none" class="section-arrow2" />
  						<path d="M 10.1 11 L 20.1 6" fill="none" stroke="rgb(68,85,255)" stroke-width="2" stroke-miterlimit="10" pointer-events="none" class="section-arrow2" />
  						<path d="M 1 11 L 11 16" fill="none" stroke="rgb(68,85,255)" stroke-width="2" stroke-miterlimit="10" pointer-events="none" id="section-arrow1" />
  						<path d="M 10.1 16 L 20.1 11" fill="none" stroke="rgb(68,85,255)" stroke-width="2" stroke-miterlimit="10" pointer-events="none" class="section-arrow1" />
  					</g>
  				</svg>
  				<span>Swipe for next section</span>
  			</div>
    	</nav>
      
      <section id="abstract">
      	<h1>Abstract</h1>

      	<p>Firmware updates are essential for the secure operation of <a href="#acr-iot">IoT</a> devices, as several recent examples of uncovered security flaws in <a href="#acr-iot">IoT</a> device firmware show.
				Firmware update mechanisms must fulfil several requirements.
				Firstly, as <a href="#acr-iot">IoT</a> devices are constrained in terms of available computing power, memory, battery power, and network bandwidth, firmware update processes must be designed with special consideration to these constraints.
				Secondly, firmware update mechanisms must be secure; if they are not, they allow an attacker to exhaust the device's resources through a <a href="#acr-dos">DoS</a> attack, block the installation of security patches, or even install arbitrary firmware.
				Thirdly, ease of use for the <a href="#acr-iot">IoT</a> device owner must be considered; ideally, it should be possible to install firmware updates without manual user intervention and they should cause minimal service downtime.
				The <a href="#acr-suit">SUIT</a> working group at the <a href="#acr-ietf">IETF</a> has published a draft for a standardized firmware update process that is designed to fulfil these requirements.
				<a href="#acr-suit">SUIT</a> has already been implemented for the <a href="#acr-iot">IoT</a> operating system RIOT using <a href="#acr-coap">CoAP</a> as the application layer protocol to transmit the update.
				In this work, we first analyse the requirements for secure software update mechanisms in the context of the <a href="#acr-iot">IoT</a> and provide a survey of existing mechanisms.
				We then design a new transport mechanism that uses <a href="#acr-mqttsn">MQTT-SN</a> and extend RIOT's implementation with it.
				Finally, we evaluate and compare the transport mechanisms <a href="#acr-mqttsn">MQTT-SN</a> and <a href="#acr-coap">CoAP</a> in a realistic testbed environment with respect to their resource requirements (flash memory, RAM and energy consumption), network protocol overhead, total update duration, and their scalability, i.e. ability to update multiple devices in parallel.
      </section>
      
      <section id="toc">
      	<h1>Contents</h1>

      	<ol>
      		<li><a href="#chapter1">Introduction</a></li>

      		<li>
      			<a href="#chapter2">Background: Application Layer Protocols for the Internet of Things</a>
		    		<ol>
		    			<li><a href="#sec-background-coap">Constrained Application Protocol (CoAP)</a></li>
		    			<li><a href="#sec-background-mqtt">Message Queuing Telemetry Transport (MQTT)</a></li>
		    			<li><a href="#sec-background-mqtt-sn">MQTT for Sensor Networks (MQTT-SN)</a></li>
		    			<li><a href="#sec-app-layer-comp">Comparison</a></li>
		    		</ol>
      		</li>

      		<li>
      			<a href="#chapter3">Related Work</a>
		    		<ol>
		    			<li><a href="#sec-rel-work-comp">Comparative Evaluations of CoAP, MQTT and MQTT-SN</a></li>
		    			<li><a href="#sec-requirements">Requirements for Software Update Mechanisms</a></li>
		    			<li><a href="#sec-lit-review">Software Update Mechanisms</a></li>
		    		</ol>
		    	</li>

      		<li>
      			<a href="#chapter4">Thesis Contribution: A New Transport Mechanism for SUIT Using MQTT-SN</a>
		    		<ol>
		    			<li><a href="#sec-design">Design</a></li>
		    			<li><a href="#sec-implementation">Implementation</a></li>
		    		</ol>
		    	</li>

      		<li>
      			<a href="#chapter5">Thesis Outcome: Evaluation and Comparison</a>
		    		<ol>
		    			<li><a href="#sec-eval-setup">Setup</a></li>
		    			<li><a href="#sec-eval-methods">Methods</a></li>
		    			<li><a href="#sec-eval-results">Results</a></li>
		    			<li><a href="#sec-eval-conclusion">Conclusion</a></li>
		    		</ol>
		    	</li>

      		<li>
		    		<a href="#chapter6">Conclusion</a>
		    		<ol>
		    			<li><a href="#sec-summary">Summary</a></li>
		    			<li><a href="#sec-future-work">Future Work</a></li>
		    		</ol>
		    	</li>
      		
      		<li><a href="#bibliography">Bibliography</a></li>
      	</ol>
      </section>
      
      <section id="acronyms">
      	<h1>Acronyms</h1>
      	
      	<dl>
      		<dt id="acr-6lowpan">6LoWPAN</dt>
      		<dd>IPv6 over Low-Power Wireless Personal Area Networks</dd>
      		<!-- <dd><a href="">Return to text</a></dd> -->

      		<dt id="acr-amqp">AMQP</dt>
      		<dd>Advanced Message Queueing Protocol</dd>

      		<dt id="acr-cbor">CBOR</dt>
      		<dd>Concise Binary Object Representation</dd>

      		<dt id="acr-coap">CoAP</dt>
      		<dd>Constrained Application Protocol</dd>

      		<dt id="acr-cose">COSE</dt>
      		<dd>CBOR Object Signing and Encryption</dd>

      		<dt id="acr-ddos">DDoS</dt>
      		<dd>Distributed Denial of Service</dd>

      		<dt id="acr-dds">DDS</dt>
      		<dd>Data Distribution Service</dd>

      		<dt id="acr-dos">DoS</dt>
      		<dd>Denial of Service</dd>

      		<dt id="acr-dtls">DTLS</dt>
      		<dd>Datagram Transport Layer Security</dd>

      		<dt id="acr-http">HTTP</dt>
      		<dd>Hypertext Transfer Protocol</dd>

      		<dt id="acr-iana">IANA</dt>
      		<dd>Internet Assigned Numbers Authority</dd>

      		<dt id="acr-ieee">IEEE</dt>
      		<dd>Institute of Electrical and Electronics Engineers</dd>

      		<dt id="acr-ietf">IETF</dt>
      		<dd>Internet Engineering Task Force</dd>

      		<dt id="acr-iot">IoT</dt>
      		<dd>Internet of Things</dd>

      		<dt id="acr-ip">IP</dt>
      		<dd>Internet Protocol</dd>

      		<dt id="acr-ipv6">IPv6</dt>
      		<dd>Internet Protocol version 6</dd>

      		<dt id="acr-lwm2m">LwM2M</dt>
      		<dd>Lightweight Machine-to-Machine</dd>

      		<dt id="acr-maclayer">MAC</dt>
      		<dd>Media Access Control</dd>

      		<dt id="acr-mac">MAC</dt>
      		<dd>Message Authentication Code</dd>

      		<dt id="acr-miot-lab">MIoT Lab</dt>
      		<dd>Magdeburg Internet of Things Lab</dd>

      		<dt id="acr-mqtt">MQTT</dt>
      		<dd>Message Queuing Telemetry Transport</dd>

      		<dt id="acr-mqttsn">MQTT-SN</dt>
      		<dd>MQTT For Sensor Networks</dd>

      		<dt id="acr-mtu">MTU</dt>
      		<dd>Maximum Transmission Unit</dd>

      		<dt id="acr-nist">NIST</dt>
      		<dd>National Institute of Standards and Technology</dd>

      		<dt id="acr-os">OS</dt>
      		<dd>Operating System</dd>

      		<dt id="acr-ota">OTA</dt>
      		<dd>Over-The-Air</dd>

      		<dt id="acr-qos">QoS</dt>
      		<dd>Quality of Service</dd>

      		<dt id="acr-ram">RAM</dt>
      		<dd>Random Access Memory</dd>

      		<dt id="acr-rsmb">RSMB</dt>
      		<dd>Really Small Message Broker</dd>

      		<dt id="acr-rssi">RSSI</dt>
      		<dd>Received Signal Strength Indication</dd>

      		<dt id="acr-rtt">RTT</dt>
      		<dd>Round Trip Time</dd>

      		<dt id="acr-suit">SUIT</dt>
      		<dd>Software Updates for Internet of Things</dd>

      		<dt id="acr-tcp">TCP</dt>
      		<dd>Transmission Control Protocol</dd>

      		<dt id="acr-tdma">TDMA</dt>
      		<dd>Time Division Multiple Access</dd>

      		<dt id="acr-tuf">TUF</dt>
      		<dd>The Update Framework</dd>

      		<dt id="acr-udp">UDP</dt>
      		<dd>User Datagram Protocol</dd>

      		<dt id="acr-uri">URI</dt>
      		<dd>Uniform Resource Identifier</dd>

      		<dt id="acr-xmpp">XMPP</dt>
      		<dd>Extensible Messaging and Presence Protocol</dd>
      	</dl>
      </section>

      <section id="chapter1" class="chapter" data-chapter-num="1">
      	<header>
		    	<p class="chapter-num"></p>
		      <h1>Introduction</h1>
        </header>
        
        <p>In contrast to the standard Internet, where humans are senders or receivers of information, the <a href="#acr-iot">IoT</a> consists of non-human “things”, e.g. lightbulbs or fridges, that communicate with each other using Internet protocols.
				They are usually low-powered devices with relatively limited memory and computing capabilities.
				Since the expected lifetimes of those devices are of considerable length, it must be possible to update their firmware when bugs or security problems become known. Otherwise, the devices run the risk of malfunctioning or becoming compromised, especially if they are connected to the public Internet.</p>

				<p>Several cases of security flaws in <a href="#acr-iot">IoT</a> devices that have become known in the past couple of years have illustrated why software updates for <a href="#acr-iot">IoT</a> devices are so important.
				For example, in 2016, security flaws were found in <a href="#acr-iot">IoT</a> surveillance cameras that had been sold in German and Swiss supermarkets. The cameras came with an insecure default configuration in which no password is set for the control panel, and automatically set up a port forwarding in the home router to make their video and audio streams publicly available over the Internet.
				A firmware update addressing the vulnerability had actually been available for months at the time of publication, however, over a third of scanned devices were still vulnerable&nbsp;<a href="#heise2016ip">[1]</a>.
				In 2020, the so-called “Ripple20” vulnerabilties were found in a TCP/IP implementation which was used by hundreds of millions of embedded and <a href="#acr-iot">IoT</a> devices. Some of them allowed remote code execution. In response to this, an updated version of the implementation was released; however, it was difficult to identify all of the affected devices,
				and it was expected that some of the affected devices cannot or will not ever have their firmware updated&nbsp;<a href="#jsof2020cve11896">[2]</a>.
				An analysis of firmware images for over sixty different HP printer models found that over 80\% of them contained third-party software with known vulnerabilities&nbsp;<a href="#cui2013firmware">[3]</a>.
				Finally, the Mirai botnet illustrates the magnitude of attacks that are possible using <a href="#acr-iot">IoT</a> devices. The botnet was involved in some of the largest known <a href="#acr-ddos">DDoS</a> attacks ever in 2016. At its peak, it had infected approximately 600,000 <a href="#acr-iot">IoT</a> and embedded devices worldwide&nbsp;<a href="#antonakakis2017understanding">[4]</a>.</p>

				<p>These examples make it obvious that software updates are an important part of the operation and maintenance phase in the lifecycle of an <a href="#acr-iot">IoT</a> device.
				The need for software updates for <a href="#acr-iot">IoT</a> devices is already widely acknowledged. % by security experts, but more recently also by the European legislature.
				At the time of writing, the most recent security guidelines published by the German Federal Office for Information Security (German: “Bundesamt für Sicherheit in der Informationstechnik” (BSI))
				and the American <a href="#acr-nist">NIST</a> both list the installation of firmware updates, especially security patches, as a basic requirement for the secure operation of <a href="#acr-iot">IoT</a> devices&nbsp;<a href="#bsi2020iot">[5, pp.&nbsp;3–4]</a><a href="#nistir8259a">[6, p.&nbsp;9]</a>.
				The issue has even been acknowledged by European legislature: In May 2019, the European parliament passed a directive&nbsp;<a href="#eu2019-771">[7]</a> which establishes a new right for consumers to receive necessary software updates for purchased goods with digital elements such as <a href="#acr-iot">IoT</a> devices.
				The German Federal Ministry of Justice and Consumer Protection
				has already published a draft bill implementing the directive&nbsp;<a href="#refe-wkrl">[8]</a>, which assumes an average length of five years during which the manufacturer is required to provide these software updates, starting at the date of purchase.</p>

				<p>However, there are several different problems with the current practices for <a href="#acr-iot">IoT</a> software updates.
				Some of them have been noted by Schneier&nbsp;<a href="#schneier2014unpatchable">[9]</a>,
				who points out that there are currently not enough incentives for <a href="#acr-iot">IoT</a> device vendors to provide software updates, and that there is no system through which device owners get notified of new software updates.
				Furthermore, ease of use and user acceptance must be considered.
				Currently, some device owners may lack the expertise required to install firmware updates on their devices.
				One survey found that in general, the average user is not likely to immediately install software updates when prompted, e.g. due to inconvenience or past negative experiences with buggy updates&nbsp;<a href="#ion2015no">[10]</a>.
				It must also be taken care that the software update process itself is secure and does not introduce new attack vectors, such as installation of a malicious software, rollbacks of security fixes, and <a href="#acr-dos">DoS</a> attacks that exhaust a device's resources (e.g. battery power) by continually attempting illegitimate updates.
				For example, a vulnerability was found in the remote firmware update functionality used in HP LaserJet printers that allowed an attacker to install arbitrary firmware because updates were only authenticated using checksums and not signed&nbsp;<a href="#cui2013firmware">[3]</a>. The printers also did not require any administrator user authentication; anyone who was allowed to print could also install updates.
				Even if cryptographic signatures are used, attackers may compromise the signing keys. For example, Ronen et al. were able to extract the secret key used to encrypt and sign updates which was shared by many Philips Hue devices, and use it to sign and install malicious firmware&nbsp;<a href="#ronen2017iot">[11]</a>.</p>

				<p>In answer to these problems, the working group <a href="#acr-suit">SUIT</a> at the <a href="#acr-ietf">IETF</a>
				is currently working on a standardized software update solution for <a href="#acr-iot">IoT</a> devices.
				The solution is intended to work even for constrained devices with as little as ~10&nbsp;KiB <a href="#acr-ram">RAM</a> and ~100&nbsp;KiB flash memory (Class 1 devices&nbsp;<a href="#rfc7228">[12]</a>).
				Their efforts focus mainly on standardizing a format for the software's metadata (also known as “manifest”), the software update architecture and the security mechanisms used to prevent attacks.
				They do not aim to standardize the mechanisms for transmitting the update to the devices,
				since <a href="#acr-iot">IoT</a> device operators are expected to already have certain infrastructure in place.
				Thus, <a href="#acr-suit">SUIT</a> aims to support all application layer (e.g. <a href="#acr-mqtt">MQTT</a>, <a href="#acr-coap">CoAP</a>) and lower layer protocols (e.g. WiFi, IEEE 802.15.4) commonly used by <a href="#acr-iot">IoT</a> devices.
				It must be noted that the majority of the <a href="#acr-suit">SUIT</a> documents&nbsp;[<a href="#rfc9019">13</a>, <a href="#ietf-suit-manifest-12">14</a>, <a href="#ietf-suit-information-model-11">15</a>] are still in draft status and <a href="#acr-suit">SUIT</a> must thus be considered a work in progress.</p>

				<p>The aim of this work is firstly to design and implement an extension of the <a href="#acr-suit">SUIT</a> implementaton that is part of <a href="https://riot-os.org/">RIOT</a>&nbsp;<a href="#baccelli2012riot">[16]</a>, an <a href="#acr-os">OS</a> for the <a href="#acr-iot">IoT</a>, which allows it to use another application layer protocol for update transmission.
				Prior to this work, only <a href="#acr-coap">CoAP</a> is supported.
				Secondly, the aim is to evaluate resource requirements, communication overhead and duration of the software update transmission in an <a href="#acr-iot">IoT</a> testbed.
				In summary, the contributions of this work are:</p>

				<ul>
					<li>Analysis and discussion of requirements for secure software update mechanisms in the context of the <a href="#acr-iot">IoT</a></li>
					<li>Survey of other proposed update solutions and comparison with SUIT</li>
					<li>Design and implementation of a new transport mechanism for <a href="#acr-suit">SUIT</a> using <a href="#acr-mqttsn">MQTT-SN</a></li>
					<li>
						Evaluation of the implementation and comparison of different transport mechanisms (<a href="#acr-mqttsn">MQTT-SN</a> and <a href="#acr-coap">CoAP</a>) in an <a href="#acr-iot">IoT</a> testbed under realistic conditions
						<ul>
							<li>Resource requirements (e.g. flash memory, <a href="#acr-ram">RAM</a>, energy consumption)</li>
							<li>Network protocol overhead</li>
							<li>Total duration of the firmware update</li>
							<li>Scalability (updating multiple devices at once)</li>
						</ul>
					</li>
				</ul>

				<h5>Thesis Structure</h5>

				The rest of this work is structured as follows:
				<a href="#chapter2">Chapter&nbsp;2</a> provides background information on the <a href="#acr-iot">IoT</a> networking stack, especially the application layer protocols <a href="#acr-coap">CoAP</a>, <a href="#acr-mqtt">MQTT</a>, and <a href="#acr-mqttsn">MQTT-SN</a>.
				<a href="#chapter3">Chapter&nbsp;3</a> gives an overview over related works: It contains a survey of performance comparisons of <a href="#acr-coap">CoAP</a>, <a href="#acr-mqtt">MQTT</a>, and <a href="#acr-mqttsn">MQTT-SN</a>.
				It also contains the discussion of the general requirements of a secure software update mechanism for <a href="#acr-iot">IoT</a> devices, a survey on other proposed software update mechanisms in the literature, and finally a comparison of the different ways in which these solutions and <a href="#acr-suit">SUIT</a> aim to fulfil the requirements.
				<a href="#chapter4">Chapter&nbsp;4</a> describes the details of our implementation and also contains a discussion of design choices that were made.
				<a href="#chapter5">Chapter&nbsp;5</a> describes the design of our evaluation and its results.
				<a href="#chapter6">Chapter&nbsp;6</a> provides a summary and some pointers for future work on the topic.
      </section>

      <section id="chapter2" class="chapter" data-chapter-num="2">
      	<header>
      		<p class="chapter-num"></p>
		      <h1><a href="#chapter2">Background</a></h1>
        </header>
        
        <p>In this chapter, we provide background information on the application layer protocols used in this work: <a href="#acr-coap">CoAP</a>, <a href="#acr-mqtt">MQTT</a> and <a href="#acr-mqttsn">MQTT-SN</a>.</p>

				<p>Below the application layer, we use a widely used network stack for the <a href="#acr-iot">IoT</a> that consists of IEEE&nbsp;802.15.4, <a href="#acr-ipv6">IPv6</a> and <a href="#acr-udp">UDP</a> or <a href="#acr-tcp">TCP</a>&nbsp;[<a href="#palattella2012standardized">17</a>, <a href="#sheng2013survey">18</a>].
				Because IEEE&nbsp;802.15.4 limits the frame length to 127&nbsp;B, but <a href="#acr-ipv6">IPv6</a> requires a minimum <a href="#acr-mtu">MTU</a> of 1280&nbsp;B,
				an adaptation layer is required in between.</p>

				<p>This is provided by <a href="#acr-6lowpan">6LoWPAN</a>, which allows the transmission of <a href="#acr-ipv6">IPv6</a> packets over IEEE&nbsp;802.15.4 by fragmenting them&nbsp;<a href="#rfc4944">[19]</a>. It also provides compression for <a href="#acr-ipv6">IPv6</a> and <a href="#acr-udp">UDP</a> headers to decrease overhead and prevent fragmentation for small payloads&nbsp;<a href="#rfc6282">[20]</a>.
				See <a href="#fig-iot-stack">Figure&nbsp;1</a> for a visual overview.</p>

				<figure id="fig-iot-stack">
					<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="331px" height="121px" viewBox="-0.5 -0.5 331 121"><defs></defs><g><rect x="0" y="0" width="330" height="120" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><rect x="10" y="90" width="180" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 100px; margin-left: 12px;"><div style="box-sizing: border-box; font-size: 0px; text-align: left;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Georgia; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">(1) Host-to-Network Layer</div></div></div></foreignObject><text x="12" y="104" fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="12px">(1) Host-to-Network Layer</text></switch></g><rect x="190" y="90" width="130" height="20" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 128px; height: 1px; padding-top: 100px; margin-left: 191px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 13px; font-family: Georgia; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">IEEE 802.15.4</div></div></div></foreignObject><text x="255" y="104" fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="13px" text-anchor="middle">IEEE 802.15.4</text></switch></g><rect x="190" y="50" width="130" height="20" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 128px; height: 1px; padding-top: 60px; margin-left: 191px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 13px; font-family: Georgia; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">IPv6</div></div></div></foreignObject><text x="255" y="64" fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="13px" text-anchor="middle">IPv6</text></switch></g><rect x="10" y="50" width="130" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 60px; margin-left: 12px;"><div style="box-sizing: border-box; font-size: 0px; text-align: left;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Georgia; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">(2) Network Layer</div></div></div></foreignObject><text x="12" y="64" fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="12px">(2) Network Layer</text></switch></g><rect x="190" y="30" width="130" height="20" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 128px; height: 1px; padding-top: 40px; margin-left: 191px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 13px; font-family: Georgia; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">TCP, UDP</div></div></div></foreignObject><text x="255" y="44" fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="13px" text-anchor="middle">TCP, UDP</text></switch></g><rect x="10" y="30" width="140" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 40px; margin-left: 12px;"><div style="box-sizing: border-box; font-size: 0px; text-align: left;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Georgia; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">(3) Transport Layer</div></div></div></foreignObject><text x="12" y="44" fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="12px">(3) Transport Layer</text></switch></g><rect x="190" y="10" width="130" height="20" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 128px; height: 1px; padding-top: 20px; margin-left: 191px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 13px; font-family: Georgia; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">CoAP, MQTT,...</div></div></div></foreignObject><text x="255" y="24" fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="13px" text-anchor="middle">CoAP, MQTT,...</text></switch></g><rect x="10" y="10" width="140" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 20px; margin-left: 12px;"><div style="box-sizing: border-box; font-size: 0px; text-align: left;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Georgia; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">(4) Application Layer</div></div></div></foreignObject><text x="12" y="24" fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="12px">(4) Application Layer</text></switch></g><rect x="190" y="70" width="130" height="20" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 128px; height: 1px; padding-top: 80px; margin-left: 191px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 13px; font-family: Georgia; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">6LoWPAN</div></div></div></foreignObject><text x="255" y="84" fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="13px" text-anchor="middle">6LoWPAN</text></switch></g><rect x="10" y="70" width="150" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe flex-start; width: 1px; height: 1px; padding-top: 80px; margin-left: 12px;"><div style="box-sizing: border-box; font-size: 0px; text-align: left;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Georgia; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">(1.5) Adaptation Layer</div></div></div></foreignObject><text x="12" y="84" fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="12px">(1.5) Adaptation Layer</text></switch></g></g><switch><g requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"/><a transform="translate(0,-5)" xlink:href="https://www.diagrams.net/doc/faq/svg-export-text-problems" target="_blank"><text text-anchor="middle" font-size="10px" x="50%" y="100%">Text is not SVG - cannot display</text></a></switch></svg>
					<figcaption>The <a href="#acr-iot">IoT</a> network stack used in this work.</figcaption>
				</figure>
				
				<h2 id="sec-background-coap"><a href="#sec-background-coap">Constrained Application Protocol (CoAP)</a></h2>

				<p><a href="#acr-coap">CoAP</a> is an application layer protocol for the <a href="#acr-iot">IoT</a> used to retrieve, update or delete resources&nbsp;<a href="#rfc7252">[21]</a>. It was designed in the “request-response” style of the <a href="#acr-http">HTTP</a>, and uses similar request methods and response codes, e.g. “GET” and “404 (Not Found)”.
				Also similar to <a href="#acr-http">HTTP</a>, resources are identified by <a href="#acr-uri">URIs</a>, which consist of the following parts:</p>

				<figure>
					<code>
						coap[s]://&lt;host&gt;[:&lt;port&gt;]&lt;path&gt;[?&lt;query&gt;]
					</code>
				</figure>

				<p>The special path prefix <code>/.well-known/</code> can be used to retrieve site-wide metadata, e.g. a list of all available resources.
				For an example <a href="#acr-coap">CoAP</a> request and response, see <a href="#fig-example-coap">Figure&nbsp;2a</a>.</p>

				<p>However, in contrast to <a href="#acr-http">HTTP</a>, <a href="#acr-coap">CoAP</a> is more suitable for constrained devices.
				It does not require connection establishment prior to the exchange of requests and responses.
				The <a href="#acr-coap">CoAP</a> header can be as small as 4&nbsp;B, while
				the <a href="#acr-http">HTTP</a> header has a fixed length of 9&nbsp;B&nbsp;<a href="#rfc7540">[22, p.&nbsp;12]</a>.
				Additionally, <a href="#acr-coap">CoAP</a>'s default transport layer protocol is <a href="#acr-udp">UDP</a> instead of <a href="#acr-tcp">TCP</a>. This is beneficial for multiple reasons. Firstly, <a href="#acr-udp">UDP</a> is more lightweight than <a href="#acr-tcp">TCP</a> because it offers fewer guarantees, e.g. messages are not acknowledged, retransmitted and may be delivered out of order.
				Secondly, <a href="#acr-udp">UDP</a> headers can be compressed by the <a href="#acr-6lowpan">6LoWPAN</a> adaptation layer (from 8&nbsp;B to 2&nbsp;B at maximum compression), while <a href="#acr-tcp">TCP</a> headers (20&nbsp;B) cannot&nbsp;<a href="#rfc6282">[20, pp.&nbsp;17--20]</a>.
				Finally, <a href="#acr-tcp">TCP</a>'s congestion control mechanism is known to cause performance issues for wireless and mobile devices&nbsp;<a href="#caceres1994effects">[23]</a>.</p>

				<p>Due to the unreliability of <a href="#acr-udp">UDP</a>, <a href="#acr-coap">CoAP</a> itself implements an optional reliability feature using 2&nbsp;B long message IDs that are contained in every <a href="#acr-coap">CoAP</a> message.
				Using this ID, duplicated messages can be discarded, and so-called “confirmable” messages can be acknowledged by the receiver. A <a href="#acr-coap">CoAP</a> message is marked as confirmable in the 2&nbsp;bit “Type” header field. If a confirmable message is not acknowledged, it is periodically re-sent after timeout periods which exponentially increase in length until it is acknowledged or a maximum number of retransmissions is reached&nbsp;<a href="#rfc7252">[21, pp.&nbsp;21&nbsp;f.]</a>.</p>

				<p><a href="#acr-coap">CoAP</a> messages should fit inside a single <a href="#acr-ip">IP</a> packet to avoid fragmentation. Therefore, a maximum payload size of 1024&nbsp;B is recommended&nbsp;<a href="#rfc7252">[21, p.&nbsp;25]</a>.
				To transmit larger amounts of data, block-wise transfer can be used&nbsp;<a href="#rfc7959">[24]</a>.
				In lossy networks, <a href="#acr-coap">CoAP</a> block-wise transfer is more efficient than <a href="#acr-6lowpan">6LoWPAN</a> fragmentation: When at least one of the <a href="#acr-6lowpan">6LoWPAN</a> fragments is still missing after a maximum wait time of 60&nbsp;s, all other fragments are flushed and must be retransmitted&nbsp;<a href="#rfc4944">[19, p.&nbsp;13]</a>, while <a href="#acr-coap">CoAP</a> blocks are individually acknowledged and retransmitted.
				The block sizes of the request and response payloads are set separately using the “Block1” and “Block2” option, respectively.
				The block options each consist of three fields: a block number (4–20&nbsp;bit), a bit indicating whether more blocks are following (“more bit”), and a block size (3&nbsp;B).
				Block sizes of [2<sup>4</sup>, 2<sup>5</sup>,..., 2<sup>10</sup>]&nbsp;B are supported.
				When the block option is used by a client when requesting a resource, the server must respond using a block size no larger than the one requested.
				See <a href="#fig-example-coap-block-wise">Figure&nbsp;2b</a> for an example <a href="#acr-coap">CoAP</a> exchange using block-wise transfer.</p>

				<figure class="has-subfigures">
					<figure id="fig-example-coap">
						<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="241px" height="231px" viewBox="-0.5 -0.5 241 231"><defs></defs><g><rect x="0" y="0" width="80" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 40 40 L 40 230" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="39.5" y="17">CoAP</text><text x="39.5" y="33">Client</text></g><rect x="35" y="70" width="10" height="110" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><rect x="160" y="0" width="80" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 200 40 L 200 230" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="199.5" y="17">CoAP</text><text x="199.5" y="33">Server</text></g><rect x="195" y="70" width="10" height="110" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 45.1 99.81 L 186.72 99.91" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 193.72 99.92 L 186.72 103.41 L 186.72 96.41 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="rgb(255, 255, 255)" stroke="none" x="58" y="66" width="125" height="32" stroke-width="0"/><text x="119.6" y="78.37">CON</text><text x="119.6" y="94.37">GET /suit-manifest</text></g><path d="M 195 148.76 L 53.2 148.76" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 46.2 148.76 L 53.2 145.26 L 53.2 152.26 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="rgb(255, 255, 255)" stroke="none" x="67" y="115" width="108" height="32" stroke-width="0"/><text x="119.5" y="127.26">ACK</text><text x="119.5" y="143.26">2.05 &lt;payload&gt;</text></g></g></svg>
						<figcaption>Using confirmable messages: When the client sends a confirmable GET request for a resource to the server, the server must acknowledge the request. Here, it sends the requested resource payload in the same message as the acknowledgment.</figcaption>
					</figure>
					<figure id="fig-example-coap-block-wise">
						<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="281px" height="231px" viewBox="-0.5 -0.5 281 231"><defs></defs><g><rect x="0" y="0" width="80" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 40 40 L 40 230" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="39.5" y="17">CoAP</text><text x="39.5" y="33">Client</text></g><rect x="35" y="70" width="10" height="150" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><rect x="200" y="0" width="80" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 240 40 L 240 230" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="239.5" y="17">CoAP</text><text x="239.5" y="33">Server</text></g><rect x="235" y="70" width="10" height="150" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 44.84 79.9 L 226.68 79.9" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 233.68 79.9 L 226.68 83.4 L 226.68 76.4 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="rgb(255, 255, 255)" stroke="none" x="51" y="48" width="179" height="30" stroke-width="0"/><text x="139.34" y="60.4">GET /suit-manifest</text><text x="139.34" y="74.4">Block1 Nr 0, More 0, Size 32</text></g><path d="M 234.84 119.95 L 53.03 119.81" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 46.03 119.8 L 53.03 116.31 L 53.03 123.31 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="rgb(255, 255, 255)" stroke="none" x="51" y="88" width="179" height="30" stroke-width="0"/><text x="139.34" y="100.37">2.05 &lt;payload&gt;</text><text x="139.34" y="114.37">Block2 Nr 0, More 1, Size 32</text></g><path d="M 45.18 159.7 L 226.88 159.84" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 233.88 159.85 L 226.88 163.34 L 226.88 156.34 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="rgb(255, 255, 255)" stroke="none" x="51" y="128" width="179" height="30" stroke-width="0"/><text x="139.68" y="140.28">GET /suit-manifest</text><text x="139.68" y="154.28">Block1 Nr 1, More 0, Size 32</text></g><path d="M 235.08 200.05 L 53.03 199.91" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 46.03 199.9 L 53.03 196.41 L 53.03 203.41 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="rgb(255, 255, 255)" stroke="none" x="51" y="168" width="179" height="30" stroke-width="0"/><text x="139.58" y="180.48">2.05 &lt;payload&gt;</text><text x="139.58" y="194.48">Block2 Nr 1, More 0, Size 32</text></g></g></svg>
						<figcaption>Using block-wise transfer: The client requests a resource block by block. The server responds with the requested blocks using the requested block size. The final block is sent with the more bit unset.</figcaption>
					</figure>
					<figcaption>Example <a href="#acr-coap">CoAP</a> requests and responses.</figcaption>
				</figure>

				<p><a href="#acr-coap">CoAP</a> also supports so-called cross-protocol proxies, which translate requests and responses between <a href="#acr-coap">CoAP</a> and another protocol.
				Because <a href="#acr-coap">CoAP</a> is quite similar to <a href="#acr-http">HTTP</a>, translation between <a href="#acr-coap">CoAP</a> and <a href="#acr-http">HTTP</a> can be easily done.
				This allows <a href="#acr-iot">IoT</a> devices that communicate over <a href="#acr-coap">CoAP</a> to access resources that are served by <a href="#acr-http">HTTP</a> servers, and vice versa.</p>

				<h2 id="sec-background-mqtt"><a href="#sec-background-mqtt">Message Queuing Telemetry Transport (MQTT)</a></h2>

				<p>The <a href="#acr-mqtt">MQTT</a> protocol&nbsp;<a href="#mqtt-5.0">[25]</a> is based on the “publish/subscribe” paradigm, which means that devices can subscribe to so-called “topics” to receive data that they are interested in, e.g. <code>living-room/temperature</code>, as well as
				publish data on a topic.
				The subscriptions are managed by a “broker”.
				When the broker receives published data, it checks which active clients are subscribed to the topic and forwards it to them.
				See <a href="#fig-example-mqtt">Figure&nbsp;3</a> for an example message exchange between a publisher, a subscriber and a broker.
				The size of the <a href="#acr-mqtt">MQTT</a> header depends on the message type, e.g. <span class="sc">Publish</span> or <span class="sc">Subscribe</span>. The <span class="sc">Publish</span> header has a minimum length of 3&nbsp;B, plus the topic length.</p>

				<figure id="fig-example-mqtt">
					<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="521px" height="261px" viewBox="-0.5 -0.5 521 261"><defs></defs><g><rect x="0" y="0" width="100" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 50 40 L 50 260" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="49.5" y="25">MQTT Client</text></g><rect x="45" y="70" width="10" height="180" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><rect x="210" y="0" width="100" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 260 40 L 260 260" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="259.5" y="25">MQTT Broker</text></g><rect x="255" y="70" width="10" height="180" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 55 120 L 246.88 120" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 253.88 120 L 246.88 123.5 L 246.88 116.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="rgb(255, 255, 255)" stroke="none" x="80" y="89" width="152" height="30" stroke-width="0"/><text x="154.5" y="100.5">SUBSCRIBE</text><text x="154.5" y="114.5">living-room/temperature</text></g><path d="M 254.81 149.92 L 63.52 149.23" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 56.52 149.2 L 63.53 145.73 L 63.51 152.73 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="rgb(255, 255, 255)" stroke="none" x="127" y="133" width="56" height="15" stroke-width="0"/><text x="154.31" y="144.06">SUBACK</text></g><rect x="420" y="0" width="100" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 470 40 L 470 260" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="469.5" y="17">MQTT Client</text><text x="469.5" y="33">(IoT Device)</text></g><rect x="465" y="70" width="10" height="140" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 464.97 79.94 L 273.12 80" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 266.12 80 L 273.12 76.5 L 273.12 83.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="rgb(255, 255, 255)" stroke="none" x="278" y="48" width="182" height="30" stroke-width="0"/><text x="368.47" y="60.47">PUBLISH</text><text x="368.47" y="74.47">living-room/temperature 24.2</text></g><path d="M 264.97 109.78 L 456.36 109.9" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 463.36 109.9 L 456.36 113.4 L 456.36 106.4 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="rgb(255, 255, 255)" stroke="none" x="337" y="93" width="56" height="15" stroke-width="0"/><text x="364.47" y="104.34">PUBACK</text></g><path d="M 254.81 200.32 L 63.12 200.32" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 56.12 200.32 L 63.12 196.82 L 63.12 203.82 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="rgb(255, 255, 255)" stroke="none" x="68" y="169" width="182" height="30" stroke-width="0"/><text x="158.31" y="180.82">PUBLISH</text><text x="158.31" y="194.82">living-room/temperature 24.4</text></g><path d="M 54.93 230.2 L 246.69 229.85" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 253.69 229.84 L 246.7 233.35 L 246.69 226.35 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="rgb(255, 255, 255)" stroke="none" x="127" y="214" width="56" height="15" stroke-width="0"/><text x="154.43" y="224.52">PUBACK</text></g><path d="M 465.13 160.02 L 273.25 160" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 266.25 160 L 273.25 156.5 L 273.25 163.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="rgb(255, 255, 255)" stroke="none" x="279" y="129" width="182" height="30" stroke-width="0"/><text x="368.63" y="140.51">PUBLISH</text><text x="368.63" y="154.51">living-room/temperature 24.4</text></g><path d="M 264.97 189.88 L 456.85 189.84" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 463.85 189.84 L 456.85 193.34 L 456.85 186.34 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="rgb(255, 255, 255)" stroke="none" x="337" y="173" width="56" height="15" stroke-width="0"/><text x="364.47" y="184.36">PUBACK</text></g></g></svg>
					<figcaption>Example <a href="#acr-mqtt">MQTT</a> publish and subscribe messages: Clients can both subscribe and publish to topics. The broker forwards all published messages on a topic to the currently subscribed clients. The success of publish and subscribe actions is indicated using <span class="sc">PubAck</span> and <span class="sc">SubAck</span> messages when using a <a href="#acr-qos">QoS</a> level >0.</figcaption>
				</figure>

				<p><a href="#acr-mqtt">MQTT</a> extends the basic publish/subscribe paradigm with additional features, such as:</p>
				
				<dl>
					<dt><a href="#acr-qos">QoS</a></dt>
					<dd>Data can be published using three different <a href="#acr-qos">QoS</a> levels:

						<ul>
							<li>Level 0 (“at most once”) does not use any kind of acknowledgements (besides <a href="#acr-tcp">TCP</a> acknowledgements between the client and the broker).</li>

							<li>Level 1 (“at least once”) additionally uses <span class="sc">PubAck</span> messages that are sent by the receiver (may be either client or broker) upon receiving the message.
							Duplicates of the message may still arrive after the <span class="sc">PubAck</span> has been sent. They must be treated like new messages, because the message ID is free for reuse after the message has been acknowledged.</li>

							<li>Level 2 (“exactly once”) uses a three-step process to ensure reliability and prevent duplicates: The receiver sends a <span class="sc">PubRec</span> (“Publish Receive”) message upon receiving the message, which lets the sender know to stop storing and retransmitting the message.
							The sender confirms this with a <span class="sc">PubRel</span> (“Publish Release”) message, which lets the receiver know it no longer needs to store the message ID to detect duplicates. The receiver finally replies with a <span class="sc">PubComp</span> (“Publish Complete”).</li>
						</ul>

						If <span class="sc">PubAck</span> (<a href="#acr-qos">QoS</a> level 1) or <span class="sc">PubRec</span> (<a href="#acr-qos">QoS</a> level 2) are missing, the message is retransmitted until it times out.
					</dd>

					<dt>Wildcard Subscriptions</dt>
					
					<dd>Two different wildcard symbols may be used to subscribe to multiple topics at once:

						<ul>
							<li>The wildcard symbol <code>#</code> may only be placed on the final level of the subscribed topic, e.g. <code>living-room/#</code>. It matches the top-level topic and all subtopics, e.g. <code>living-room</code>, <code>living-room/temperature</code>, <code>living-room/light-status/lamp1</code> and <code>living-room/light-status/lamp2</code>.</li>
							<li>The wildcard symbol <code>+</code> may be placed at any level of the subscribed topic, e.g. <code>house/+/temperature</code>. It matches any single level, e.g. <code>house/living-room/temperature</code> and <code>house/dining-room/temperature</code>.</li>
						</ul>
					</dd>

					<dt>Retained Messages<dt>
					
					<dd>
						<p>When the <span class="sc">Retain</span> bit is set in a <span class="sc">Publish</span> message, the <a href="#acr-mqtt">MQTT</a> broker must store the message and send it to future subscribers of the topic upon subscription.
						It is useful when updates on a topic are irregular or infrequent because it ensures that any subscriber receives an initial value directly after subscribing.</p>

						<p>There can be at most one retained message for a topic at any given time. If another message is published with the <span class="sc">Retain</span> bit set, it replaces the previous retained message.</p>

						<p>If the <a href="#acr-qos">QoS</a> level of the retained message is set to 0, it may be discarded by the broker at any time; if the <a href="#acr-qos">QoS</a> level is 1 or 2, the semantics of the level must be honored, i.e. the retained message must be delivered at least once or exactly once to each future subscriber.
					</dd>
				</dl>

				<h2 id="sec-background-mqtt-sn"><a href="#sec-background-mqtt-sn">MQTT for Sensor Networks (MQTT-SN)</a></h2>

				<p>In the <a href="#acr-iot">IoT</a> context, one downside of the <a href="#acr-mqtt">MQTT</a> protocol is that it can only be operated using <a href="#acr-tcp">TCP</a> on the transport layer, while <a href="#acr-udp">UDP</a> is generally preferred for constrained, mobile and wireless devices, as discussed in <a href="#sec-background-coap">Chapter 2.1</a>.
				Thus, a second standard called <a href="#acr-mqttsn">MQTT-SN</a>&nbsp;<a href="#mqtt-sn-1.2">[26]</a> was developed specifically for these use cases, which uses <a href="#acr-udp">UDP</a> instead of <a href="#acr-tcp">TCP</a>.
				It supports all of the features described in <a href="#sec-background-mqtt">Chapter 2.2</a> and the full set of message types defined by the <a href="#acr-mqtt">MQTT</a> protocol, except for <span class="sc">Auth</span> messages, which are used for authentication using challenge/response methods.</p>

				<p>In architecture, <a href="#acr-mqttsn">MQTT-SN</a> can be considered an extension of <a href="#acr-mqtt">MQTT</a>. Besides an <a href="#acr-mqtt">MQTT</a> broker, it additionally requires an <a href="#acr-mqttsn">MQTT-SN</a> gateway, which may be integrated with the broker or standalone. The standalone case is shown in <a href="#fig-mqtt-sn-arch">Figure&nbsp;4</a>.</p>

				<figure id="fig-mqtt-sn-arch">
					<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="501px" height="61px" viewBox="-0.5 -0.5 501 61"><defs></defs><g><rect x="380" y="0" width="120" height="60" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="439.5" y="27">MQTT-SN Client</text><text x="439.5" y="43">(IoT Device)</text></g><rect x="190" y="0" width="120" height="60" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="249.5" y="27">MQTT-SN</text><text x="249.5" y="43">Gateway</text></g><rect x="0" y="0" width="120" height="60" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="59.5" y="35">MQTT Broker</text></g><path d="M 119.52 10.14 L 183.63 10.01" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 188.88 10 L 181.89 13.52 L 183.63 10.01 L 181.88 6.52 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><path d="M 190 50 L 126.37 49.98" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 121.12 49.98 L 128.12 46.48 L 126.37 49.98 L 128.12 53.48 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><path d="M 310 10 L 378.23 10.18" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 383.48 10.2 L 376.47 13.68 L 378.23 10.18 L 376.49 6.68 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><path d="M 379.76 49.92 L 316.37 49.99" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 311.12 50 L 318.11 46.49 L 316.37 49.99 L 318.12 53.49 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="120" y="9" width="70" height="40" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 29px; margin-left: 155px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 11px; font-family: Georgia; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;"><div style="font-size: 11px;">MQTT</div><div style="font-size: 11px;">over TCP</div></div></div></div></foreignObject><text x="155" y="32" fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="11px" text-anchor="middle">MQTT...</text></switch></g><rect x="305" y="9" width="80" height="40" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 29px; margin-left: 345px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 11px; font-family: Georgia; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;"><div style="font-size: 11px;">MQTT-SN</div><div style="font-size: 11px;">over UDP</div></div></div></div></foreignObject><text x="345" y="32" fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="11px" text-anchor="middle">MQTT-SN...</text></switch></g></g><switch><g requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"/><a transform="translate(0,-5)" xlink:href="https://www.diagrams.net/doc/faq/svg-export-text-problems" target="_blank"><text text-anchor="middle" font-size="10px" x="50%" y="100%">Text is not SVG - cannot display</text></a></switch></svg>
					<figcaption>Architecture components used by <a href="#acr-mqttsn">MQTT-SN</a>: In addition to an <a href="#acr-mqtt">MQTT</a> broker, <a href="#acr-mqttsn">MQTT-SN</a> requires a gateway that translates between its clients, which speak <a href="#acr-mqttsn">MQTT-SN</a> over <a href="#acr-udp">UDP</a>, and the broker, which speaks <a href="#acr-mqtt">MQTT</a> over <a href="#acr-tcp">TCP</a>. The gateway may be integrated with the broker or it may be a standalone component, as shown here.</figcaption>
				</figure>

				<p>Besides the <a href="#acr-udp">UDP</a> support, <a href="#acr-mqttsn">MQTT-SN</a> offers the following advantages for constrained devices and wireless networks:</p>

				<dl>
					<dt>Support for Topic IDs</dt>
					<dd>
						<p>Instead of variable-length topic names, which can cause a large overhead on top of published messages, <a href="#acr-mqttsn">MQTT-SN</a> uses 2&nbsp;B long “topic IDs”.
						Prior to use, they must be registered either by the gateway or by the client.
						Alternatively, <a href="#acr-mqttsn">MQTT-SN</a> also supports pre-defined topic IDs which can be used without registration.</p>

						<p>Topic IDs can also be used in version 5 of <a href="#acr-mqtt">MQTT</a> itself, where they are called “topic aliases”. However,
						brokers are not required by the specification to keep using topic aliases when forwarding messages that were published using a topic alias. This is because publishers and subscribers are meant to be independent from one another, and thus a publisher's decision to use a topic alias cannot automatically carry over to subscribers.
						As a result, topic aliases are simply translated and never used for outgoing <span class="sc">Publish</span> messages by some broker implementations such as the widely used <a href="https://github.com/eclipse/mosquitto">Mosquitto</a>.
							
						<p>At the time of writing, the issue of using topic aliases for outgoing <span class="sc">Publish</span> messages in Mosquitto is being discussed (see <a href="https://github.com/eclipse/mosquitto/issues/1757">here</a> and <a href="https://www.eclipse.org/lists/mosquitto-dev/msg02505.html">here</a>) and the feature is planned to be added in an upcoming version (see <a href="https://github.com/eclipse/mosquitto/commit/de9780343b09d2d2d1c2bda6f2747c961e2fa2c1">here</a>).
					</dd>

					<dt>Server/Gateway Discovery</dt>
					<dd>
						Gateways may periodically broadcast <span class="sc">Advertise</span> messages to allow clients to keep an updated list of online gateways.
						Additionally, clients may broadcast <span class="sc">SearchGw</span> messages to let others in the network know that they are looking for a gateway. Gateways or other clients may respond to this using a <span class="sc">GwInfo</span> message, which includes the address of an available gateway.
					</dd>
					
					<dt>Keep-Alive for Sleeping Clients</dt>
					<dd>
						<p>A client may let the gateway know that it is about to enter a sleep state by setting the “Sleep Duration” field in the <span class="sc">Disconnect</span> message. For that duration, the gateway will buffer packets on subscribed topics and deliver them when the client next comes back online and sends a <span class="sc">PingReq</span> to the gateway. After sending all buffered packets, the gateway answers the ping and the client may go back to sleep.</p>

						<p>A similar feature is also included in <a href="#acr-mqtt">MQTT</a>: If the “Clean Start” flag in the <span class="sc">Connect</span> message is set to zero, a persistent session is started. After it ends, the broker will continue buffering messages on the client's subscribed topics and deliver them when the client next connects. However, this is only mandatory for messages with <a href="#acr-qos">QoS</a> >0, and the <span class="sc">Connect</span> procedure is less lightweight than the <span class="sc">PingReq</span> procedure.
					</dd>

					<dt><a href="#acr-qos">QoS</a> Level -1</dt>
					<dd>
						Clients may publish messages without any previous connection setup with a gateway using the <a href="#acr-qos">QoS</a> level -1. This offers even less assurances than <a href="#acr-qos">QoS</a> level 0, because it is unclear whether the gateway adress is correct or the gateway is still online. However, this also saves the overhead of connection setup and teardown.
					</dd>
				</dl>

				<h2 id="sec-app-layer-comp"><a href="#sec-app-layer-comp">Comparison</a></h2>

				<p>In this section, we discuss advantages and disadvantages of <a href="#acr-coap">CoAP</a>, <a href="#acr-mqtt">MQTT</a> and <a href="#acr-mqttsn">MQTT-SN</a> based on the protocol specifications which we briefly described in the previous sections.
				For an overview over performance comparisons of <a href="#acr-coap">CoAP</a>, <a href="#acr-mqtt">MQTT</a> and <a href="#acr-mqttsn">MQTT-SN</a> implementations, see <a href="#sec-rel-work-comp">Chapter 3.1</a>.</p>

				<p>The publish/subscribe model used by <a href="#acr-mqtt">MQTT</a> and <a href="#acr-mqttsn">MQTT-SN</a> has some advantages over the request/response model used by <a href="#acr-coap">CoAP</a>.
				As mentioned, <a href="#acr-mqtt">MQTT</a> and <a href="#acr-mqttsn">MQTT-SN</a> can easily support sleeping devices by buffering packets at the broker.
				Additionally, the broker simplifies one-to-many or many-to-many communication between larger numbers of <a href="#acr-iot">IoT</a> devices, since they do not need to know each others network addresses to communicate, only the broker's network address.
				It must be noted that a publish/subscribe extension for <a href="#acr-coap">CoAP</a> exists&nbsp;<a href="#ietf-core-coap-pubsub-09">[27]</a>, but it is still in draft status and thus has not been widely implemented.</p>

				<p>Currently, another advantage of <a href="#acr-mqtt">MQTT</a> over <a href="#acr-coap">CoAP</a> is that it has a larger user base&nbsp;<a href="#iot-developer-survey-2018">[28, pp.&nbsp;38&nbsp;f.]</a>.
				There is no data on the number of users of <a href="#acr-mqttsn">MQTT-SN</a>, but it can be assumed that it is the least used out of all three protocols. This is reflected in a much lower number of <a href="#acr-mqttsn">MQTT-SN</a> implementations available, which also receive much lower contribution activity. For a short overview of available <a href="#acr-mqttsn">MQTT-SN</a> implementations, see <a href="#sec-choice-mqtt-sn-impl">Section&nbsp;4.2.1</a>.</p>

				<p>In summary, <a href="#acr-mqtt">MQTT</a> and <a href="#acr-mqttsn">MQTT-SN</a> are most suited for the exchange of small amounts of current information such as sensor data in many-to-many fashion.
				<a href="#acr-mqttsn">MQTT-SN</a> is more suitable for wirelessly connected constrained devices than <a href="#acr-mqtt">MQTT</a>, but it has a much smaller user base and lacks well-maintained software support.
				<a href="#acr-coap">CoAP</a> is most suited for the transfer of data of any size from servers to clients. Especially the transfer of large amounts of data is well-supported through the block-wise transfer option. It also provides interoperability with other protocols used in the wider Internet using cross-protocol proxies, most notably for <a href="#acr-http">HTTP</a>.
      </section>

      <section id="chapter3" class="chapter" data-chapter-num="3">
      	<header>
      		<p class="chapter-num"></p>
		      <h1><a href="#chapter3">Related Work</a></h1>
        </header>
        
        <p>In this chapter, we present and discuss related works.
The first section presents an overview over previous comparative evaluations of the two application layer protocols <a href="#acr-coap">CoAP</a> and <a href="#acr-mqtt">MQTT</a>.
The second section describes general requirements for secure firmware update solutions.
The third section presents an overview over works describing firmware update mechanisms, including <a href="#acr-suit">SUIT</a>, and finally compares how they fulfill the requirements.</p>

				<h2 id="sec-rel-work-comp"><a href="#sec-rel-work-comp">Comparative Evaluations of CoAP, MQTT and MQTT-SN</a></h2>

				<p>The performance of application layer protocols for the <a href="#acr-iot">IoT</a> has been evaluated and compared by several authors using several different metrics.
				This section gives an overview.</p>

				<p>A similar survey of evaluations of application layer protocols, which includes not only <a href="#acr-coap">CoAP</a> and <a href="#acr-mqtt">MQTT</a>, but also <a href="#acr-dds">DDS</a>, <a href="#acr-amqp">AMQP</a> and <a href="#acr-xmpp">XMPP</a>, was published by Dizdarević et al.&nbsp;<a href="#dizdarevic2019survey">[29]</a>
				Unfortunately, <a href="#acr-mqttsn">MQTT-SN</a> is not included in their survey.</p>

				<p>It must be noted that not all performance differences measured can be ascribed to the protocols themselves. The specific implementation used obviously also has an impact on the measured performance.
				For example, a comparison of different <a href="#acr-coap">CoAP</a> implementations by Iglesias-Urkia et al.
				found significant differences in <a href="#acr-rtt">RTT</a>, CPU and memory usage between them, even when they were implemented in the same programming language&nbsp;<a href="#iglesias2017analysis">[30]</a>.</p>

				<h3>Transmission times</h3>

				<p>The message transmission time, delay or <a href="#acr-rtt">RTT</a> is a well-studied metric that is included in most evaluations.
				Several of them find that <a href="#acr-mqtt">MQTT</a> performs better than <a href="#acr-coap">CoAP</a>, especially when packet losses and retransmissions occur:</p>

				<p>Thantharate et al. 
				measured the transmission duration of five consecutive messages in a simulated <a href="#acr-iot">IoT</a> testbed&nbsp;<a href="#thantharate2019coap">[31]</a>.
				Their results show that the average transmission time of <a href="#acr-mqtt">MQTT</a> messages with both <a href="#acr-qos">QoS</a> level 1 or 2 is at least three times as fast as that of <a href="#acr-coap">CoAP</a> confirmable messages.
				<a href="#acr-mqtt">MQTT</a> with <a href="#acr-qos">QoS</a> level 2 is slightly slower than <a href="#acr-qos">QoS</a> level 1 due to the increased acknowledgement overhead.
				However, it is unclear what causes the measured time differences. By default, <a href="#acr-coap">CoAP</a> uses a stop-and-wait protocol which allows only one outstanding request or unacknowledged message at a time, while <a href="#acr-mqtt">MQTT</a> runs over <a href="#acr-tcp">TCP</a>, which uses a sliding window protocol with larger window sizes. 
				<a href="#acr-coap">CoAP</a> may have achieved better transmission durations if it was also configured to use larger window sizes.</p>

				<p>Similarly, Bideh et al. measured transmission times
				and found that <a href="#acr-mqtt">MQTT</a> is up to seven times as fast as <a href="#acr-coap">CoAP</a>&nbsp;<a href="#bideh2020energy">[32]</a>.
				They state this is because <a href="#acr-tcp">TCP</a> uses a more efficient retransmission algorithm which uses <a href="#acr-rtt">RTT</a> measurements, while <a href="#acr-coap">CoAP</a> uses an arbitrary fixed value range (between <code>ACK_TIMEOUT</code> and <code>ACK_TIMEOUT</code> &centerdot; <code>ACK_RANDOM_FACTOR</code>) for its acknowledgment wait timeout.
				Thus, <a href="#acr-tcp">TCP</a> can trigger a first retransmission faster than <a href="#acr-coap">CoAP</a> when the network <a href="#acr-rtt">RTT</a> is low.
				The effect can be lessened by decreasing the <code>ACK_TIMEOUT</code> parameter. However, even when decreasing it to the minimum of 1&nbsp;s, they find that <a href="#acr-coap">CoAP</a> still performs worse than <a href="#acr-mqtt">MQTT</a>.</p>

				<p>Collina et al. also found that <a href="#acr-mqtt">MQTT</a> performs with lower latencies when there is high packet loss&nbsp;<a href="#collina2014internet">[33]</a>. They also state that this is because of <a href="#acr-tcp">TCP</a>'s faster retransmissions.
				Like Bideh et al., they were able to improve the performance of <a href="#acr-coap">CoAP</a> by lowering the parameters <code>ACK_TIMEOUT</code> and <code>ACK_RANDOM_FACTOR</code>. With these tuned parameters, <a href="#acr-coap">CoAP</a> achieves a performance similar to <a href="#acr-mqtt">MQTT</a>. 
				However, the lowered parameters cause risk of unnecessary retransmissions, which may congest the network. RFC&nbsp;7252 states that additional congestion control mechanisms must be used if <code>ACK_TIMEOUT</code> is decreased from its default value&nbsp;<a href="#rfc7252">[21, p.&nbsp;28]</a>.</p>

				<p>Two evaluations consider the transmission of larger amounts of data.
				Bideh et al. measured transmission durations for a large file (870&nbsp;KiB), which is transmitted in 870&nbsp;blocks when using <a href="#acr-coap">CoAP</a> and in a single message when sent over <a href="#acr-mqtt">MQTT</a>&nbsp;<a href="#bideh2020energy">[32]</a>. In this case, <a href="#acr-mqtt">MQTT</a> is twice as fast.
				Mun et al. performed time measurements
				of the transmission of 50&nbsp;kB large messages using different block sizes from 128–1920&nbsp;B and found that <a href="#acr-mqtt">MQTT</a> performs better for large block sizes of more than 1024&nbsp;B because there is less fragmentation&nbsp;<a href="#mun2016assessment">[34]</a>. When sent over <a href="#acr-coap">CoAP</a>, these blocks are fragmented twice due to its limited payload size.
				These results show that fragmentation has a negative impact on transmission durations.</p>

				<p>In some cases, <a href="#acr-coap">CoAP</a> performs similar to or even better than <a href="#acr-mqtt">MQTT</a>.
				In the evaluation by Mun et al., <a href="#acr-coap">CoAP</a> performs better than <a href="#acr-mqtt">MQTT</a> when messages are smaller than 1024&nbsp;B&nbsp;<a href="#mun2016assessment">[34]</a>.
				Collina et al. find that when there is low packet loss, <a href="#acr-mqtt">MQTT</a> and <a href="#acr-coap">CoAP</a> perform the same&nbsp;<a href="#collina2014internet">[33]</a>.
				Mijovic et al. 
				also found that <a href="#acr-coap">CoAP</a> and <a href="#acr-mqtt">MQTT</a> with <a href="#acr-qos">QoS</a> level 0 achieve very similar <a href="#acr-rtt">RTTs</a>, but <a href="#acr-mqtt">MQTT</a> with <a href="#acr-qos">QoS</a> 1 is slowed down by the additional application layer acknowledgements by a factor between 2 and 3&nbsp;<a href="#mijovic2016comparing">[35]</a>.</p>

				<p>In their survey, Dizdarević et al. also found that the transport layer protocol is a major factor for performance, and that <a href="#acr-tcp">TCP</a>-based protocols often achieve worse latencies in evaluations than the <a href="#acr-udp">UDP</a>-based ones&nbsp;<a href="#dizdarevic2019survey">[29]</a>.
				Larmo et al. found in network simulations that <a href="#acr-mqtt">MQTT</a> messages arrive with increased delays when the <a href="#acr-tcp">TCP</a> session is terminated in between messages due to <a href="#acr-tcp">TCP</a>'s three-way handshake&nbsp;<a href="#larmo2018comparison">[36]</a>.
				They also found that if the <a href="#acr-iot">IoT</a> device's radio is periodically turned off to conserve energy (“duty cycling”), a minimum delay is added to each transmission originating at the device, especially if it is using <a href="#acr-tcp">TCP</a>, because it cannot receive downlink messages such as the <a href="#acr-tcp">TCP</a> <span class="sc">Syn Ack</span> of a connection establishment until it is awake again.</p>

				<p><a href="#acr-mqttsn">MQTT-SN</a> is not included in many evaluations.
				Gündoğan et al. compared it against <a href="#acr-coap">CoAP</a>&nbsp;<a href="#gundogan2018ndn">[37]</a>.
				using ARM Cortex M3 nodes in the FIT <a href="#acr-iot">IoT</a> testbed&nbsp;<a href="#adjih2015fit">[38]</a>.
				They found that with a push/pull interval of 5&nbsp;s,
				the push-based <a href="#acr-coap">CoAP</a> <span class="sc">Put</span> and <a href="#acr-mqttsn">MQTT-SN</a> <span class="sc">Publish</span> do not differ significantly in the time required for the transmission,
				whereas the pull-based <a href="#acr-coap">CoAP</a> <span class="sc">Get</span> is slightly slower.
				With a shorter push/pull interval of 50&nbsp;ns, the delays for confirmable <a href="#acr-coap">CoAP</a> <span class="sc">Put</span> messages increase significantly due to application layer retransmissions. <a href="#acr-coap">CoAP</a> <span class="sc">Get</span> and <a href="#acr-mqttsn">MQTT-SN</a> <span class="sc">Publish</span> messages do not experience significantly decreased delays.
				In the evaluation by Mun et al., <a href="#acr-mqttsn">MQTT-SN</a> performs the worst overall; however, they note that this may be due to the low level of maturity of the implementation used (Eclipse Paho)&nbsp;<a href="#mun2016assessment">[34]</a>.</p>

				<h3>Energy consumption</h3>

				<p>Dizdarević et al. found that <a href="#acr-coap">CoAP</a> is more energy-efficient than <a href="#acr-mqtt">MQTT</a> in all surveyed comparisons, though both are more efficient than non-<a href="#acr-iot">IoT</a>-specific protocols like <a href="#acr-http">HTTP</a>&nbsp;<a href="#dizdarevic2019survey">[29]</a>.</p>

				<p>Larmo et al. also found in their network simulations that <a href="#acr-mqtt">MQTT</a> causes more energy consumption than <a href="#acr-coap">CoAP</a> due to the increased amount of radio transmission time caused by <a href="#acr-tcp">TCP</a> overhead such as the three-way-handshake&nbsp;<a href="#larmo2018comparison">[36]</a>.</p>

				<p>Bideh et al. transmitted payloads of different sizes
				and found that <a href="#acr-coap">CoAP</a> consumes slightly less energy for payloads of up to 1024&nbsp;B since the overhead of connection setup is the dominant factor for such small payloads&nbsp;<a href="#bideh2020energy">[32]</a>.
				They conclude that data should be aggregated as much as possible to minimize energy consumption, since more frequent transmissions of small payloads are costly, especially when the communication setup and teardown need to be performed every time.
				For larger payloads, <a href="#acr-coap">CoAP</a> consumes significantly more energy than <a href="#acr-mqtt">MQTT</a>, again due to the fragmentation.</p>

				<p>In the comparison of <a href="#acr-coap">CoAP</a>, <a href="#acr-mqtt">MQTT</a> and <a href="#acr-mqttsn">MQTT-SN</a> done by Mun et al.&nbsp;<a href="#mun2016assessment">[34]</a>,
				the energy usage measurements are highly similar to the total transmission times measured, which means that as described before,
				<a href="#acr-coap">CoAP</a> performs the best, except for large messages of more than 1024&nbsp;B, where <a href="#acr-mqtt">MQTT</a> performs better due to less fragmentation, and <a href="#acr-mqttsn">MQTT-SN</a> performs the worst overall.
				Mun et al. also find that the energy usage of all three protocols is heavily influenced by the network conditions (e.g. jitter and <a href="#acr-rtt">RTT</a>): The worse the network conditions are, the more energy they consume.</p>

				<h3>Traffic overhead</h3>

				<p>Obviously, the traffic overhead incurred by headers and control traffic increases with the <a href="#acr-qos">QoS</a> level for <a href="#acr-mqtt">MQTT</a>. For <a href="#acr-coap">CoAP</a>, it increases when confirmable messages are used.
				In their survey, Dizdarević et al. found that <a href="#acr-coap">CoAP</a> consumes less bandwidth than <a href="#acr-mqtt">MQTT</a> in all surveyed comparisons&nbsp;<a href="#dizdarevic2019survey">[29]</a>.
				Our survey arrives at the same result.
				Unfortunately, <a href="#acr-mqttsn">MQTT-SN</a> is not included in any overhead evaluations.</p>

				<p>Chen et al. found that <a href="#acr-mqtt">MQTT</a> sends approximately 76&nbsp;B of header and control data for every 100&nbsp;B of payload, while <a href="#acr-coap">CoAP</a> sends only approximately 36&nbsp;B for every 100&nbsp;B of payload when using non-confirmable messages&nbsp;<a href="#chen2016performance">[39]</a>.
				This increased overhead of <a href="#acr-mqtt">MQTT</a> is probably due to the control messages that are necessary before actually transmitting any payload, i.e. the <span class="sc">Connect</span> and <span class="sc">ConnAck</span> messages.</p>

				<p>Mijovic et al. also found that <a href="#acr-coap">CoAP</a> has less protocol overhead than <a href="#acr-mqtt">MQTT</a> (both <a href="#acr-qos">QoS</a> 0 and 1), because the <a href="#acr-udp">UDP</a> header is smaller and there are no transport-layer acknowledgments&nbsp;<a href="#mijovic2016comparing">[35]</a>.
				When transmitting 100&nbsp;B of payload, the payload makes up more than 30&nbsp;% of transmitted bytes when using <a href="#acr-coap">CoAP</a>, but less than 20&nbsp;% of transmitted bytes when using <a href="#acr-mqtt">MQTT</a>.</p>

				<h3>Packet loss rates</h3>

				<p>Chen et al. found that <a href="#acr-mqtt">MQTT</a> experiences no packet loss even in lossy network conditions at the cost of increased latency for the received packets and increased control traffic overhead, while <a href="#acr-coap">CoAP</a> experiences packet loss rates approximately equal to the network packet loss rate&nbsp;<a href="#chen2016performance">[39]</a>.
				This is not surprising, since lost <a href="#acr-mqtt">MQTT</a> messages will be retransmitted by <a href="#acr-tcp">TCP</a> even when <a href="#acr-qos">QoS</a> level 0 is used, while the <a href="#acr-udp">UDP</a>-based <a href="#acr-coap">CoAP</a> does not retransmit packets by default.
				Unfortunately, they have not included <a href="#acr-coap">CoAP</a>'s confirmable messages in their evaluation.</p>

				<p>Gündoğan et al. also found in their measurements in the FIT <a href="#acr-iot">IoT</a> testbed that with a short transmission interval of 50&nbsp;ms, significant packet loss occurs for non-confirmable <a href="#acr-coap">CoAP</a> messages, while
				confirmable <a href="#acr-coap">CoAP</a> and <a href="#acr-mqttsn">MQTT-SN</a> PUBLISH messages did not experience packet loss because missing packets could be successfully retransmitted&nbsp;<a href="#gundogan2018ndn">[37]</a>.</p>

				<h3>Conclusion</h3>

				<p>In conclusion, <a href="#acr-mqtt">MQTT</a>'s largest downside when compared to <a href="#acr-coap">CoAP</a> appears to be the overhead caused by <a href="#acr-tcp">TCP</a> due to the required connection setup and teardown and its larger header size.
				This overhead can lead to increased message transmission durations, energy consumption and traffic overhead, especially when the connection is re-established frequently.
				However, <a href="#acr-tcp">TCP</a> also offers some advantage against <a href="#acr-coap">CoAP</a>, namely through its sliding window protocol compared to <a href="#acr-coap">CoAP</a>'s stop-and-wait and its faster retransmissions.
				This gives <a href="#acr-mqtt">MQTT</a> an advantage especially in environments with high packet loss, where retransmissions are frequent.
				However, <a href="#acr-coap">CoAP</a>'s approach is more suitable for constrained devices, because it does not require to keep <a href="#acr-rtt">RTT</a> measurements or to support multiple simultaneously outstanding acknowledgments.</p>

				<p><a href="#acr-mqttsn">MQTT-SN</a> is unfortunately not included in many evalutions. Gündoğan et al.'s results suggest that it offers a performance similar to <a href="#acr-coap">CoAP</a>. However, further evaluation is needed. As Mun et al. noted, the lacking maturity of implementations that are currently available may also negatively impact <a href="#acr-mqttsn">MQTT-SN</a>'s performance results.</p>

				<p>Several evaluations note the negative performance impact of fragmentation. Here, <a href="#acr-coap">CoAP</a> is disadvantaged because it has a much lower maximum payload size than <a href="#acr-mqtt">MQTT</a> (1024&nbsp;B vs. ~256&nbsp;MB) and therefore forces more fragmentation at the application layer. However, <a href="#acr-coap">CoAP</a>'s maximum payload size is much more realistic for constrained devices and networks and thus, in practice and for a fair comparison, <a href="#acr-mqtt">MQTT</a> should also be limited to a similar payload size.</p>

				<h2 id="sec-requirements"><a href="#sec-requirements">Requirements for Software Update Mechanisms</a></h2>
				
				<p>In this section, we survey requirements that apply to all secure software update mechanisms.</p>

				<p>First, we must clarify terminology, particularly the difference between the terms “firmware updates” and “software updates”.
				“Firmware update” refers to the complete replacement of a device's entire software, while “software update” refers more generally to the replacement of some part of a device's software with a newer version. It is less specific to the <a href="#acr-iot">IoT</a> or embedded context and also describes the update of a package on a Linux system, for example.
				Currently, most constrained <a href="#acr-iot">IoT</a> devices use full firmware updates only, however, it has been suggested that <a href="#acr-iot">IoT</a> software may become less monolithic in the future, so that different parts of it will need to be updated independently&nbsp;<a href="#padilla2016future">[40]</a>.
				(For example, the embedded <a href="#acr-os">OS</a> <a href="https://www.tockos.org">Tock</a> uses a non-monolothic approach. It separates the core <a href="#acr-os">OS</a> from (third-party) applications that are dynamically loadable at runtime&nbsp;<a href="#levy2017multiprogramming">[41]</a>.)
				Smaller update sizes would also reduce network traffic and therefore the update duration and energy consumption&nbsp;[<a href="#bauwens2020over">42</a>, <a href="#mottola2008figaro">43</a>].
				Thus, we use the more general term “software update” throughout this work where it is possible, as the <a href="#acr-suit">SUIT</a> standard drafts also do.</p>

				<p>We now present a list of security requirements for software update mechanisms based on a survey of several other works.
				Firstly, the general information security principles of confidentiality, integrity, availability, and authenticity, which are named in the ISO~27000 standards series as the defining aspects of “information security”&nbsp;<a href="#iso27000">[44, p.&nbsp;4]</a>, apply to firmware update mechanisms:</p>

				<h3>Confidentiality</h3>

				<p>It must be possible to encrypt both the software image and the metadata to ensure its confidentiality and prevent ”read attacks”. Attackers may use unencrypted images for reverse-engineering.</p>

				<h3>Integrity of the Image and Metadata</h3>

				<p>The integrity of the software itself and its metadata must be verified.
				The device must check the integrity of the firmware update, i.e. that the update has not been tampered with along the way from the source to the <a href="#acr-iot">IoT</a> device.</p>

				<h3>Availability of the Updated Device</h3>
				
				<p>An <a href="#acr-iot">IoT</a> device usually provides some service using its sensors and actuators. A software update usually requires a device to reboot and thus temporarily disrupts this service. It must be possible to schedule updates so that the availability of the service is not disrupted at critical times.
				The update process should also include fail-safes, e.g. for the case when a firmware update turns out to be invalid after it is received or the reboot fails&nbsp;<a href="#padilla2016future">[45]</a>.</p>

				<h3>Authentication and Authorization of the Update Source</h3>

				<p>The update source must be authenticated and authorized. 
				No unauthenticated or unauthorized source should be able to initiate a firmware update of a device.
				This can be done using cryptographic signatures, for example.
				Trust anchors or keys used by the device to perform the authentication may expire or change so that it is necessary to update them&nbsp;[<a href="#rfc8240">46</a>, <a href="#zandberg2019secure">47</a>].
				Ideally, the device manufacturer or vendor should not be the only authorized source&nbsp;<a href="#cui2013firmware">[3]</a>, so that the devices do not become obsolescent when they are no longer actively supported by the manufacturer or the manufacturer shuts down&nbsp;<a href="#klint2016nest">[48]</a>, which is undesirable both from a customer's and from an ecological perspective.</p>

				<p>Samuel et al. define a set of principles that make a software update system resilient against attacks when a subset of signing keys has been compromised&nbsp;<a href="#samuel2010survivable">[49]</a>.
				Firstly, there should be separation of responsibilities over multiple keys so that the attacker's power is limited when a key is compromised.
				Secondly, signatures using multiple keys should be required.
				Thirdly, it must be possible to revoke keys. Keys may also be automatically revoked after a certain amount of time or number of uses to encourage frequent replacement.
				Finally, keys used for very security-sensitive purposes should be stored on systems not connected to the public Internet or not connected to a network at all.
				To prevent key compromises in the first place, widely trusted cryptographic algorithms and large key sizes should be used.
				They also identify the information that must be authenticated by a software update mechanism: the content of the updates,
				the availability of the updates, and the
				repository state (i.e. software versions available).
				They applied these principles in the design of <a href="#acr-tuf">TUF</a>, which is described in <a href="#sec-tuf">Section&nbsp;3.3.2</a>.</p>

				<p>Secondly, there are security requirements related to the specific potential weaknesses of software update mechanisms.
				Some cases of such weaknesses were already described in <a href="#chapter1">Section&nbsp;1</a>.
				Cappos et al. classify several types of attacks on software repositories&nbsp;<a href="#cappos2008look">[50]</a>: replay attacks (resending older versions), arbitrary package attacks (sending a different software than requested), freeze attacks (freezing the version a client sees and preventing updates; this type of attack was also previously described by Bellissimo et al.&nbsp;<a href="#cappos2008look">[51]</a>), extraneous dependency attacks (inserting additional dependencies that must be satisfied), and endless data attacks (sending endless amounts of data instead of the software image).
				These attack types can be carried out when an attacker compromises a software repository, i.e. is able to respond to client requests with arbitrary data, but they do not require a signing key to be compromised.
				Cappos et al. suggest that extraneous dependency attacks can be mitigated by signing update metadata which contains the dependency list,
				and replay attacks can be mitigated by including a timestamp in the software metadata that must not be older than the timestamp of the currently installed software.
				Endless data attacks can be mitigated by placing a cap on the maximum amount of data downloaded.
				To detect freeze attacks, they recommend to use signed root metadata files that contain hashes of all package metadata files served by the repository. The files are small, so they can have short expiry times and be updated and resigned frequently&nbsp;<a href="#cappos2008look">[50]</a>.</p>

				<p>Karthik et al. describe further types of attacks&nbsp;<a href="#karthik2016uptane">[52]</a>: read attacks (reading contents of firmware updates, e.g. to reverse-engineer), slow retrieval attack (slowing down transmission of firmware updates to exploit vulnerabilities in the meantime), and drop-request attacks (blocking network traffic of firmware updates).</p>

				<p>In addition to replay attacks, an attacker may also send an outdated software version that is newer than the currently installed version, but still not the latest available one&nbsp;<a href="#ietf-suit-information-model-11">[15, p.&nbsp;18]</a>. Langiu et al. call this the “update freshness” property&nbsp;<a href="#langiu2019upkit">[53]</a>, which must be ensured.</p>

				<p>Finally, there are also some usability requirements that should be met by a software update solution:</p>

				<h3>Suitability for Constrained <a href="#acr-iot">IoT</a> Devices</h3>

				<p>An attempt at a definition of the term “constrained device” has been made in RFC 2778&nbsp;<a href="#rfc7228">[12]</a>.
				According to this RFC, devices can be “constrained” in the sense of limited amount of flash memory, <a href="#acr-ram">RAM</a>, processing power, available (battery) power or accessibility once deployed.
				Additionally,
				the networks to which they are connected may themselves be constrained in some way, e.g. by low throughput or high packet loss rates.</p>

				<p>The software update mechanism must adhere to these constraints. It cannot require memory or processing power exceeding the capabilities of constrained devices. It should have minimal energy consumption, which means that the network traffic and the total processing and transmission time spent on the update should be minimized&nbsp;[<a href="#itani2009petra">54</a>, <a href="#mottola2008figaro">43</a>].</p>

				<p>Additionally, <a href="#acr-iot">IoT</a> devices are sometimes installed in inaccessible locations. Therefore, software updates must be possible over wireless connections&nbsp;[<a href="#itani2009petra">54</a>, <a href="#mottola2008figaro">43</a>].
				Devices may also not be constantly connected to a network if they are mobile. In these cases, pull-based approaches are preferable over push-based approaches&nbsp;<a href="#cappos2008look">[51]</a>.</p>

				<h3>Minimal User Interaction</h3>

				<p>Software updates are expected to work automatically, i.e. with minimal or even no user involvement or attendance&nbsp;[<a href="#rfc9019">14</a>, <a href="#padilla2016future">40</a>, <a href="#schneier2014unpatchable">10</a>, <a href="#frisch2017ota">45</a>].
				Some types of <a href="#acr-iot">IoT</a> devices may not be able to ask for confirmation because they lack an appropriate user interface&nbsp;<a href="#cappos2008look">[51]</a>.</p>

				<p>However, there are several reports of <a href="#acr-iot">IoT</a> devices losing certain functionalities or even being bricked after installing software updates&nbsp;[<a href="#doctorow2015philips">55</a>, <a href="#doctorow2016hp">56</a>, <a href="#carman2017smart">57</a>].
				Also, software updates may include “breaking” changes. A software update that changes the behaviour and output of an <a href="#acr-iot">IoT</a> device, e.g. the format of the sensor data it reports, may break systems that rely on this output down the line&nbsp;<a href="#rfc8240">[46, p.&nbsp;18]</a>.
				Therefore, it must be possible to turn off automatic updates.</p>

				<h3>Targeting Subsets of Devices</h3>
				
				<p>It should be possible to limit the installation of a firmware update to a certain subset of devices&nbsp;[<a href="#mottola2008figaro">43</a>, <a href="#frisch2017ota">45</a>]. Most obviously, a firmware should only be installed on the devices with the matching type of hardware. Additionally, updates may be targeted using other device attributes, such as location or group (e.g. test or production devices).
				Some use cases may additionally require that the update mechanism ensures atomicity, i.e. that either none or all of the targeted nodes successfully install an update&nbsp;[<a href="#bauwens2020over">42</a>, <a href="#mottola2008figaro">43</a>].</p>

				<h3>Monitoring</h3>
				
				<p>It should be possible to monitor the state of the <a href="#acr-iot">IoT</a> devices, including at least their currently installed firmware version and whether an update was successful or not&nbsp;[<a href="#frisch2017ota">45</a>, <a href="#rfc8240">46</a>].</p>

				<h3>Partial or Differential Updates</h3>
				
				<p>As discussed before, an <a href="#acr-iot">IoT</a> device's software may be modular. In that case, the software update mechanism needs to support partial updates, which may be installed e.g. using dynamic linking.
				Also, differential updates may be desirable to minimize the network traffic&nbsp;[<a href="#bauwens2020over">42</a>, <a href="#rfc8240">46</a>].</p>
				
				<h2 id="sec-lit-review"><a href="#sec-lit-review">Software Update Mechanisms</a></h2>

				<p>In this section, we describe the design of several existing software update mechanisms, starting with <a href="#acr-suit">SUIT</a>. We focus primarily on update mechanisms designed for constrained devices.
				We specifically examine if and how they meet the requirements described in the previous section.</p>

				<h3 id="sec-rw-suit">Software Updates for Internet of Things (SUIT)</h3>

				<p>The <a href="#acr-suit">SUIT</a> working group at the <a href="#acr-ietf">IETF</a> aims to standardize a secure software update mechanism for constrained devices with as little as ~10&nbsp;KiB <a href="#acr-ram">RAM</a> and ~100&nbsp;KiB flash memory (Class 1 according to RFC 7228&nbsp;<a href="#rfc7228">[12]</a>).
				This would lower development costs for <a href="#acr-iot">IoT</a> device vendors, who would no longer need to design and implement their own update mechanism, and ensure a certain level of quality.
				The <a href="#acr-suit">SUIT</a> documents specify a format for update manifests, the update architecture and the update process including the security mechanisms used.
				Transport mechanisms, status tracker functionality and discovery mechanisms for status trackers and software repository servers are explicitly not standardized, because they may be implemented in various ways using already existing protocols, e.g. the <a href="#acr-lwm2m">LwM2M</a> protocol for <a href="#acr-iot">IoT</a> device management.
				<a href="#acr-suit">SUIT</a> is not limited to full firmware updates. It supports the updating of arbitrary data, including partial software updates, configuration data, or cryptographic keys&nbsp;<a href="#rfc9019">[13, p.&nbsp;3]</a>.</p>

				<p>Although <a href="#acr-suit">SUIT</a> is still a work in progress, there is significant interest in its early support, e.g. from the many researchers using RIOT&nbsp;<a href="#baccelli2018riot">[58]</a>, the open-source <a href="#acr-iot">IoT</a> operating system used in this work.
				An implementation of <a href="#acr-suit">SUIT</a> was <a href="https://github.com/RIOT-OS/RIOT/pull/11818">added to the RIOT code base in October 2019</a>.
				<a href="#acr-suit">SUIT</a> was chosen for integration over other software update mechanisms because RIOT focuses on providing support for open, standard-based protocols and specifications.</p>

				<h4>Update architecture</h4>

				<figure id="fig-suit-arch">
					<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="591px" height="229px" viewBox="-0.5 -0.5 591 229"><defs></defs><g><rect x="470" y="80" width="120" height="60" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="529.5" y="115">IoT Device</text></g><rect x="230" y="0" width="120" height="60" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="289.5" y="27">Firmware</text><text x="289.5" y="43">Server</text></g><rect x="230" y="160" width="120" height="60" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="289.5" y="187">Status Tracker</text><text x="289.5" y="203">Server</text></g><rect x="0" y="80" width="120" height="60" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="59.5" y="107">Firmware</text><text x="59.5" y="123">Author</text></g><path d="M 120 110 L 224.85 33.75" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 229.1 30.66 L 225.49 37.61 L 224.85 33.75 L 221.38 31.94 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="rgb(255, 255, 255)" stroke="none" x="140" y="62" width="71" height="48" stroke-width="0"/><text x="174.58" y="73.62">Firmware</text><text x="174.58" y="89.62">manifest</text><text x="174.58" y="105.62">and image</text></g><path d="M 350 188 L 464.7 111.53" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 469.07 108.62 L 465.19 115.42 L 464.7 111.53 L 461.3 109.59 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="395" y="113" width="51" height="32" stroke-width="0"/><text x="419.95" y="124.82">Status</text><text x="419.95" y="140.82">queries</text></g><path d="M 470 140 L 355.3 216.47" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 350.93 219.38 L 354.81 212.58 L 355.3 216.47 L 358.7 218.41 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="374" y="175" width="54" height="32" stroke-width="0"/><text x="399.61" y="187.2">Status</text><text x="399.61" y="203.2">updates</text></g><path d="M 350 30 L 464.12 77.55" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 468.97 79.57 L 461.16 80.11 L 464.12 77.55 L 463.85 73.65 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="rgb(255, 255, 255)" stroke="none" x="375" y="28" width="71" height="48" stroke-width="0"/><text x="409.19" y="39.54">Firmware</text><text x="409.19" y="55.54">manifest</text><text x="409.19" y="71.54">and image</text></g></g></svg>
					<figcaption>The components of <a href="#acr-suit">SUIT</a>'s architecture: Besides the <a href="#acr-iot">IoT</a> device itself, a firmware and a status tracker server are required. The firmware server serves the software and manifests, while the status tracker server triggers and monitors updates.</figcaption>
				</figure>

				<p>The <a href="#acr-suit">SUIT</a> architecture consists of three components&nbsp;<a href="#rfc9019">[13, pp.&nbsp;7&nbsp;f.]</a>. It is shown in <a href="#fig-suit-arch">Figure&nbsp;5</a>. Firstly, there is the <a href="#acr-iot">IoT</a> device itself. It has one or more microcontrollers with associated bootloaders whose software may be updated. The device's software must implement update functionality which allows it to interact with the tracker and firmware servers, parse and verify the firmware manifest and store the downloaded firmware image.
				Secondly, there is the firmware server, which stores and distributes the firmware manifests and images.
				Finally, there is the status tracker server. It notifies devices of new firmware versions and receives status information from the devices (e.g. current firmware version, available flash memory). It can trigger a firmware update in a device.
				The firmware and the status tracker servers may be co-located on the same machine.</p>

				<h4>Update manifest format</h4>

				<p><a href="#acr-suit">SUIT</a> manifests contain metadata about an update. Their structure is defined
				in the standard draft describing the manifest&nbsp;<a href="#ietf-suit-manifest-12">[14]</a>, while the manifest fields are defined in the information model&nbsp;<a href="#ietf-suit-information-model-11">[15]</a>.
				(At the time of writing, version 12 of the manifest standard draft is the most current one, however the RIOT implementation of SUIT is still based on version 9&nbsp;<a href="#ietf-suit-manifest-09">[59]</a>. The changes to the manifest structure between the two versions are only minor, so that the description here applies equally to both.)
				In total, the draft defines 24 manifest fields, seven of which are mandatory to include, such as a sequence number and a storage location.
				See <a href="#tab-manifest">Table 1</a> for an example manifest which was generated using the <a href="https://github.com/RIOT-OS/RIOT/tree/master/dist/tools/suit/suit-manifest-generator">manifest generator tool that is included in RIOT</a>.
				The <a href="#acr-suit">SUIT</a> manifest also contains command sequences which describe how the receiver should process the manifest.
				Commands are either conditions that must be true or directives that must be executed.
				They are available for all processing steps usually required by an update process, i.e. signature and digest verification, parameter comparisons, fetching, copying and transformation of data, and code execution.</p>

				<p>The manifests are encoded using <a href="#acr-cbor">CBOR</a>, a binary data format specifically designed to generate small messages and require only little code to parse and generate&nbsp;<a href="#rfc7049">[60]</a>, and are authenticated using <a href="#acr-cose">COSE</a>&nbsp;<a href="#rfc8152">[61]</a>.
				They are distributed in a container called the “<a href="#acr-suit">SUIT</a> Envelope” alongside an authentication wrapper containing one or more <a href="#acr-cose">COSE</a> signatures or <a href="#acr-mac">MACs</a>.
				When using the <a href="https://github.com/RIOT-OS/RIOT/tree/master/dist/tools/suit/suit-manifest-generator/suit_tool">RIOT SUIT tool</a> to generate the signed version of a manifest,
				a single <a href="#acr-cose">COSE</a> signature of the hash of the manifest
				is added to the authentication wrapper.</p>

				<table id="tab-manifest">
					<caption>An example <a href="#acr-suit">SUIT</a> manifest.</caption>
					<thead>
						<tr>
							<td style="width: 25%;">Field name</td>
							<td style="width: 45%;">Description</td>
							<td style="width: 30%;">Example</td>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Manifest Version ID</td>
							<td>Version of the manifest format used</td>
							<td>1</td>
						</tr>
						<tr>
							<td>Manifest Sequence Number</td>
							<td>Monotonically increasing sequence number, e.g. UTC timestamp.
							<td>1603813981</td>
						</tr>
						<tr>
							<td>Vendor ID</td>
							<td>Unique device vendor ID.</td>
							<td><code>riot-os.org</code></td>
						</tr>
						<tr>
							<td>Class ID</td>
							<td>Class of devices that can accept the update.</td>
							<td><code>nrf52dk</code></td>
						</tr>
						<tr>
							<td>Image Size</td>
							<td>Size of the update image in bytes.</td>
							<td><code>85488</code></td>
						</tr>
						<tr>
							<td>Offset</td>
							<td>Storage offset in bytes.</td>
							<td><code>8196</code></td>
						</tr>
						<tr>
							<td>Image Digest</td>
							<td>Hash digest of the update image.</td>
							<td><code>f5ff..., SHA256</code></td>
						</tr>
						<tr>
							<td><a href="#acr-uri">URI</a></td>
							<td>Location from which the update image can be fetched.</td>
							<td><code>coap://[2001:db8::1]/fw/nrf52dk/update-slot1.riot.bin</code></td>
						</tr>
				</table>

				<h4 id="sec-suit-process">Update process</h4>

				<p>The <a href="#acr-suit">SUIT</a> update process consists of the following steps&nbsp;<a href="#rfc9019">[13, pp.&nbsp;9–11]</a>:</p>

				<ol>
					<li>
						A new software update is uploaded to the firmware server by an authenticated and authorized source.
						The status tracker server is made aware of this.
					</li>
					<li>
						The <a href="#acr-iot">IoT</a> device is notified of the newly available firmware image using a push-based approach, where the status tracker server pushes a notification to the device, or a pull-based approach, where the device periodically polls the status tracker server for available firmware images.
					
						The update manifest and image are transported from the firmware server to the device via an unspecified transport mechanism.
						Multicast or broadcast protocols may be used to efficiently distribute them to multiple devices at once.
						
						The device validates the firmware manifest's signature to authenticate the update's source. 
						The manifest and the image can either be transported separately, or the image can be embedded into the manifest. As described above, the manifest contains the software's <a href="#acr-uri">URI</a> and an associated fetch command.
						If they are transported separately, the device can validate the manifest before starting the download of the image, and abort the update process if the manifest fails any check.
						The image is stored at the storage location specified in the manifest, e.g. at a certain flash memory offset.</li>
					
					<li>
						Once the firmware image is downloaded, the installation may be initiated in one of the following ways:
					
						<ul>
							<li>The client immediately proceeds with the installation.</li>
							<li>The client delays the update until a certain condition is met (e.g. a certain time of day, battery level or until the device operator acceptst&nbsp;<a href="#ietf-suit-manifest-12">[14, pp.&nbsp;56–60]</a>.</li>
							<li>The client waits for a trigger by the status tracker server.</li>
						</ul>
						
						The bootloader then boots from the new firmware image.
					</li>
					<li>
						While the firmware update process is ongoing, the status tracker server tracks its progress, e.g. whether the update is in progress, successfully completed, or failed (and why).
					</li>
				</ol>

				<p>See <a href="#fig-suit-flow-coap">Figure&nbsp;6</a> for the sequence of messages that are sent when <a href="#acr-coap">CoAP</a> is used as the transport mechanism.
				It shows how the current implementation of SUIT in RIOT works.
				As can be seen, a <a href="#acr-coap">CoAP</a> <span class="sc">Post</span> request is used by the status tracker server to inform the <a href="#acr-iot">IoT</a> device of the newly available update. The <a href="#acr-uri">URI</a> of the firmware manifest is transmitted within the payload of this request.
				The <a href="#acr-iot">IoT</a> device then pulls the manifest and the update itself from the firmware server using block-wise <span class="sc">Get</span> requests.</p>
					
				<figure id="fig-suit-flow-coap">
					<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-0.5 -0.5 591 351"><defs></defs><g><rect x="0" y="0" width="100" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 50 40 L 50 100" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="49.5" y="17">Firmware</text><text x="49.5" y="33">Author</text></g><rect x="45" y="70" width="10" height="20" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><rect x="140" y="0" width="100" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 190 40 L 190 340" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="189.5" y="17">Firmware</text><text x="189.5" y="33">Server</text></g><rect x="185" y="70" width="10" height="260" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 55 70 L 176.88 70" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 183.88 70 L 176.88 73.5 L 176.88 66.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="119.5" y="66.5">Upload Manifest</text><text x="119.5" y="82.5">+ Image</text></g><rect x="260" y="0" width="100" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 310 40 L 310 140" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="309.5" y="17">Status Tracker</text><text x="309.5" y="33">Server</text></g><rect x="305" y="70" width="10" height="70" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><rect x="420" y="0" width="100" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 470 40 L 470 350" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="469.5" y="25">IoT Device</text></g><rect x="465" y="70" width="10" height="270" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 195 79.66 L 296.77 79.4" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 303.77 79.38 L 296.78 82.9 L 296.76 75.9 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="249.5" y="74.02">Notify</text></g><path d="M 314.97 90.02 L 456.88 90.14" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 463.88 90.15 L 456.88 93.64 L 456.89 86.64 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><text x="389.46" y="86.58">CoAP POST</text><text x="389.46" y="102.58">/suit/trigger coap://...</text></g><path d="M 465 169.15 L 203.65 169.94" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 196.65 169.96 L 203.64 166.44 L 203.66 173.44 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="263" y="151" width="136" height="17" stroke-width="0"/><text x="329.5" y="164.06">CoAP GET /manifest</text></g><path d="M 475.4 235.73 L 500 236 L 500 246 L 483.57 246.08" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 476.57 246.11 L 483.55 242.58 L 483.59 249.58 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="13px"><text x="505.15" y="234.5">Validate</text><text x="505.15" y="250.5">manifest</text></g><path d="M 195 200.02 L 456.88 199.18" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 463.88 199.15 L 456.89 202.68 L 456.87 195.68 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="286" y="181" width="88" height="17" stroke-width="0"/><text x="329.5" y="194.09">CoAP ACK ...</text></g><path d="M 475.4 325.73 L 500 326 L 500 336 L 483.57 336.08" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 476.57 336.11 L 483.55 332.58 L 483.59 339.58 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="13px"><text x="503.14" y="327.5">Proceed with</text><text x="503.14" y="343.5">installation</text></g><path d="M 464.61 130.01 L 322.95 129.85" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 315.95 129.84 L 322.95 126.35 L 322.94 133.35 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="355" y="111" width="71" height="17" stroke-width="0"/><text x="389.11" y="124.42">CoAP ACK</text></g><path d="M 465 259.15 L 203.65 259.94" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 196.65 259.96 L 203.64 256.44 L 203.66 263.44 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="271" y="241" width="119" height="17" stroke-width="0"/><text x="329.5" y="254.06">CoAP GET /image</text></g><path d="M 195 290.02 L 456.88 289.18" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 463.88 289.15 L 456.89 292.68 L 456.87 285.68 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="286" y="271" width="88" height="17" stroke-width="0"/><text x="329.5" y="284.09">CoAP ACK ...</text></g><path d="M 203.12 319.99 L 456.88 319.18" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 196.12 320.02 L 203.11 316.49 L 203.13 323.49 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><path d="M 463.88 319.15 L 456.89 322.68 L 456.87 315.68 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="198" y="301" width="265" height="17" stroke-width="0"/><text x="329.5" y="314.09">(Repeat until all blocks are transferred)</text></g><path d="M 203.12 229.99 L 456.88 229.18" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 196.12 230.02 L 203.11 226.49 L 203.13 233.49 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><path d="M 463.88 229.15 L 456.89 232.68 L 456.87 225.68 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="198" y="211" width="265" height="17" stroke-width="0"/><text x="329.5" y="224.09">(Repeat until all blocks are transferred)</text></g></g></svg>
					<figcaption>Sequence diagram of a software update using <a href="#acr-suit">SUIT</a> with a push notification and <a href="#acr-coap">CoAP</a> as the transport mechanism: The status tracker server pushes an update notification to the device using a <span class="sc">Put</span> request. The device then downloads manifest and image using block-wise <span class="sc">Get</span> requests.</figcaption>
				</figure>

				<h3>Others</h3>

				<p>In this section, we provide an overview over other proposed software update mechanisms, focusing primarily on mechanisms designed for constrained devices.
				Finally, we compare them to <a href="#acr-suit">SUIT</a>.</p>

				<h4 id="sec-tuf">The Update Framework, Uptane and ASSURED</h4>

				<p><a href="#acr-tuf">TUF</a> is a framework for software update retrieval. It authenticates updates using crypographic signatures and was designed to be able to survive the compromise of some of its signing keys using the four principles already described in <a href="#sec-requirements">Section&nbsp;3.2</a>.
				It was first described by Samuel et al&nbsp;<a href="#samuel2010survivable">[49]</a>, and
				is now a <a href="https://theupdateframework.io">part of the Linux Foundation's Cloud Native Computing Foundation and in productive use at several companies</a>.
				The protocol specification is openly available&nbsp;<a href="#2020tuf">[62]</a>.
				<a href="#acr-tuf">TUF</a> uses four different metadata files:
				<code>root.txt</code> (keys of root role and roles delegated by root),
				<code>release.txt</code> (latest versions, hashes and lengths of all metadata files except <code>timestamp.txt</code>),
				<code>timestamp.txt</code> (version, hash and length of latest <code>release.txt</code>),
				and <code>targets.txt</code> (available update files including hash digests, file size and optionally, custom information such as version or dependencies).
				Each metadata file has at least one associated role with a signing key that is only responsible for signing that file. Multiple signatures may be required.
				There can also be multiple hierarchical <code>targets.txt</code> files and keys, e.g. for update files provided from different sources.
				All metadata files also have an expiration time.</p>

				<p>When downloading an update, the first step of <a href="#acr-tuf">TUF</a> is to get the latest <code>release.txt</code> as specified by <code>timestamp.txt</code> and to check its length and hash.
				If <code>release.txt</code> indicates that a new <code>root.txt</code> is available, <a href="#acr-tuf">TUF</a> starts over.
				If <code>release.txt</code> indicates that a new <code>targets.txt</code> is available, <a href="#acr-tuf">TUF</a> updates its list of available files using the new version.
				When <a href="#acr-tuf">TUF</a> is instructed by an upper software update layer to fetch one of the available files, it does so and checks its hash and length against the ones given by the <code>targets.txt</code> before returning the file.</p>

				<p>Thus, the targets, release and timestamp roles share responsibility over the available update files so that all three must be compromised to allow an attacker to get a client to install malicious software.
				Freeze attacks are possible once the timestamp key is compromised because it allows an attacker to continually resign a frozen version of <code>timestamp.txt</code>. This prevents the release of a new <code>release.txt</code> and thus also of a new <code>targets.txt</code> or <code>root.txt</code>.
				However, the duration of the freeze attack is limited by the earliest expiration date of the other metadata files.
				Once the attack is noticed, the timestamp key can be replaced.
				Only a compromise of the root key(s) would be completely fatal to the system's security, because the attacker can sign a new <code>root.txt</code> containing his own keys for the other roles.</p>

				<p><a href="#acr-tuf">TUF</a> was not designed for constrained devices, and it is not well-suited for them. It requires the updated device to choose which updates to install, to resolve dependencies and to validate multiple cryptographic signatures. Thus, update mechanisms based on <a href="#acr-tuf">TUF</a> have been proposed that outsource these tasks to other components, e.g. ASSURED&nbsp;<a href="#asokan2018assured">[62]</a> and Uptane&nbsp;<a href="#karthik2016uptane">[52]</a>.
				ASSURED extends <a href="#acr-tuf">TUF</a> with a “controller” component which communicates with the repository on behalf of the constrained device, and takes on the tasks listed above and then transmits the update to the constrained device over a secure channel. The device only needs to confirm the authenticity of the controller and the constraints given in the update metadata, e.g. device class.
				Similarly, Uptane, which was created especially to update electronic control units (ECUs) in automobiles,
				adds a “director” role that is responsible for creating and signing a list of softwares to be installed specifically when an automobile requests updates. Due to the heterogeneous levels of constrainedness of the ECUs, one of them is chosen to be the primary who communicates directly with the director and performs the checks, and then distributes the software to all secondaries.
				Uptane's design also includes several other changes, such as an external time server which ECUs periodically contact with a nonce. The time server returns the signed current time and nonce.
				This is necessary because <a href="#acr-tuf">TUF</a> requires the updated system to have an accurate clock to make use of the expiration timestamps.
				Uptane also uses an A/B slot system to ensure that there is always a bootable image available.</p>

				<h4>UpKit</h4>

				<p>With UpKit, Langiu et al. propose a software update mechanism that is supposed to be lightweight, efficient, open-source, and not dependent on any specific network protocol, hardware platform or <a href="#acr-os">OS</a>&nbsp;<a href="#langiu2019upkit">[53]</a>.
				Their goals therefore align quite closely with those of <a href="#acr-suit">SUIT</a>.
				Langiu et al. provide <a href="https://github.com/updatekit/upkit">implementations</a> for three different <a href="#acr-os">OSs</a> (RIOT, Contiki-NG, and Zephyr) and multiple hardware platforms.</p>

				<p>UpKit's infrastructure consists of a vendor server, update server, and update client in the <a href="#acr-iot">IoT</a> device.
				The vendor server pushes new firmware images and signed metadata (the so-called “manifest”) to the update server. The manifest contains the firmware version, size, hash, offset, and application and hardware platform ID.
				The update server announces the new version's availability. The update client can then send a request for it, including its device ID and a nonce. The update server appends the nonce to the update metadata, signs it and sends it to the update client.
				Using the nonce (if it is sufficiently random&nbsp;<a href="#rfc4086">[64]</a>), the freshness of the information is guaranteed. Unlike <a href="#acr-suit">SUIT</a>, they prefer nonces over timestamps because secure time sources are usually not available to <a href="#acr-iot">IoT</a> devices, and expiry timestamps may be set too far in the future.
				Once the update client receives this information, it verifies both signatures and the metadata, such as the firmware version. If all checks are successful, the image is downloaded and its hash is compared. Finally, the image can be booted.
				UpKit supports the usage of flexible memory slots for update installation, e.g. A/B slots.</p>

				<h4>FiGaRo</h4>

				<p>Mottola et al. specify a software reconfiguration process for wireless sensor networks called FiGaRo (FIne Grained SoftwAre RecOnfiguration)&nbsp;<a href="#mottola2008figaro">[43]</a>.
				It is implemented on top of the Contiki <a href="#acr-os">OS</a>.
				In FiGaRo, the node software is structured into components that have interfaces (i.e. services they provide), dependencies on other components, and a version.
				Interfaces are represented as structs containing function pointers which always point to the implementation that is currently used.
				A management layer at the node keeps a representation of the current software configuration's dependency tree.
				When a new component arrives at the node, it checks whether all dependencies are satisfied. If they are, the component is installed and run if there is either no other component already implementing the same interface or the component that is currently installed has an older version.
				Components are replaced using dynamic linking.
				The component updates are limited to a subset of nodes using node attributes: First, each node's attributes must be declared (e.g. its hardware). They are piggybacked onto each outgoing message, overheard by all nodes in range, and used to build a mesh routing table that contains node attributes.
				Then, the target of the component update can be declared as a boolean function of the attributes (e.g. <code>Board == NUCLEO-F767ZI && Battery >= 75</code>).</p>

				<h4>Others</h4>

				<p>Frisch et al. present a software update mechanism for ESP8266-based <a href="#acr-iot">IoT</a> devices&nbsp;<a href="#frisch2017ota">[45]</a>. They use an infrastructure consisting of a firmware repository, a home automation controller and several <a href="#acr-iot">IoT</a> devices, which communicate over WiFi and <a href="#acr-mqtt">MQTT</a>.
				The repository serves firmware images and metadata files containing version numbers and cryptographic signatures of the images over <a href="#acr-http">HTTP</a>.
				There is one metadata file per device type containing the metadata of the most current available firmware version.
				The devices use a two-slot system for storing firmware images. They publish state information like currently used firmware version and slot over <a href="#acr-mqtt">MQTT</a> after start-up.
				Periodically, they poll the repository for the newest version of the relevant metadata file. A poll can also be triggered by publishing a message on a certain <a href="#acr-mqtt">MQTT</a> topic.
				If a different version than the currently running one is returned, the download is started using an <a href="#acr-http">HTTP</a> <span class="sc">Get</span> request.</p>

				<p>While many firmware update mechanisms are available, none is yet well-established in the <a href="#acr-iot">IoT</a>. Schmidt et al. believe this is due to their overly complicated nature&nbsp;<a href="#schmidt2019how">[65]</a>. They therefore propose a new “minimal” mechanism.
				Their system consists of only a firmware server and the <a href="#acr-iot">IoT</a> devices.
				The firmware images sent by the server are encrypted using a pre-shared symmetric key and signed using the server's private key. They are accompanied by metadata (version, file size and IDs of keys to be used) which is also signed. The metadata is transmitted and validated first.
				As with <a href="#acr-suit">SUIT</a>, the transport mechanism used by the server is not specified.
				They implement a bootloader that is responsible for checking the validity of the signatures and the firmware version.
				Their system also uses a two-slot setup of the device's flash memory.</p>

				<h3 id="chapter3-5">Comparison</h3>

				<p>In this section, we examine if and how <a href="#acr-suit">SUIT</a> and the other reviewed update mechanisms fulfil the requirements described in <a href="#sec-requirements">Section&nbsp;3.2</a>.</p>

				<h4>Confidentiality</h4>

				<p>Schmidt et al. use symmetric keys to encrypt the transmitted firmware images, and include an encryption key ID in the update metadata.
				<a href="#acr-suit">SUIT</a> supports the optional encryption of the software image, also using symmetric keys. For encrypted software, the manifest includes an “encryption wrapper” that specifies which key should be used to decrypt the image and a list of processing steps necessary to decrypt the image&nbsp;<a href="#ietf-suit-information-model-11">[15, pp.&nbsp;11&nbsp;f., 15]</a>.</p>

				<p>In any case, traffic may be encrypted using appropriate transport layer security protocols, such as <a href="#acr-dtls">DTLS</a> for <a href="#acr-udp">UDP</a>.</p>

				<h4>Integrity of the Image and Metadata</h4>

				<p>The mechanisms described by Frisch et al. and Schmidt et al. use signed images.
				As described above, <a href="#acr-tuf">TUF</a> and its derivatives Uptane and ASSURED use signed hashes of the software images in their metadata files.
				Similarly, UpKit and <a href="#acr-suit">SUIT</a> include the hash of the image in the signed manifest.</p>

				<p>When the <a href="#acr-iot">IoT</a> device receives the update metadata, it first validates the signature using the public key of an authorized entity (which must be already known to the device).
				During this validation, changes to the manifest by unauthorized entities can be detected.
				If the check is successful, the device compares the image digest contained in the metadata to the digest of the received image.
				In the case of <a href="#acr-suit">SUIT</a>, this check is part of the command sequence included in the manifest.
				During this check, changes to the image can be detected.</p>

				<p>In any case, the integrity of the image and metadata can also be protected against man-in-the-middle attacks by transmitting it over a secured channel, as described above.</p>

				<h4>Availability of the Updated Device</h4>

				<p>Uptane, UpKit and <a href="#acr-suit">SUIT</a> as well as the mechanisms described by Frisch et al. and Schmidt et al. support A/B updates using two memory slots, so that there is a firmware to fall back to if the reboot into the new version fails.</p>

				<p>As described above, <a href="#acr-suit">SUIT</a> allows the scheduling of updates using commands that instruct the device to wait until a certain condition is met (e.g. a certain time of day or battery level).
				The mechanism described by Frisch et al. allows only rudimentary scheduling using update triggers published over <a href="#acr-mqtt">MQTT</a>.</p>

				<p>An automatic rollback when the device cannot reestablish connection to the status tracker server after an update is not part of any of the surveyed mechanisms, but it could be added to the application logic.</p>

				<h4>Authentication and Authorization of the Update Source</h4>

				<p>The authenticity of the update metadata is generally established through one or more signatures, which must be validated by the device.
				All mechanisms except FiGaRo and the one described by Frisch et al. use signed metadata.
				The mechanisms described by Frisch et al. and Schmidt et al. sign the update image directly.</p>

				<p>In UpKit and <a href="#acr-suit">SUIT</a>, the authenticity of the update image is linked to the manifest's through the included hash digest.
				Furthermore, <a href="#acr-suit">SUIT</a> supports the usage of access control lists, which must be implemented in application code, to grant different rights to different actors&nbsp;<a href="#ietf-suit-information-model-11">[15, p.&nbsp;29]</a>.</p>

				<h4>Resilience Against Software Update-Specific Attacks</h4>

				<p>See <a href="#tab-suit-mitigation">Table&nbsp;2</a> for an overview of how <a href="#acr-suit">SUIT</a> defends itself against the different types of attacks introduced in <a href="#sec-requirements">Section&nbsp;3.2</a>.</p>

				<table id="tab-suit-mitigation">
					<caption>Mitigation strategies used by <a href="#acr-suit">SUIT</a> to defend against different types of attacks on the software update process.</caption>
					<thead>
						<tr>
							<td style="width: 33%;">Attack type</td>
							<td style="width: 33%;">Scenario</td>
							<td><a href="#acr-suit">SUIT</a>'s defense</td>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td rowspan="2">Replay attack</td>
							<td>Attacker sends a version older than the currently installed one.</td>
							<td>Monotonic sequence number in the manifest (signed)</td>
						</tr>
						<tr>
							<td>Attacker replays an update meant for another device.</td>
							<td>Vendor, device and device class ID conditions in the manifest (signed)</td>
						</tr>
						<tr>
							<td>Arbitrary package attack</td>
							<td>Attacker sends an arbitrary image instead of the requested one.</td>
							<td>Image hash in the manifest (signed)</td>
						</tr>
						<tr>
							<td>Update freshness attack</td>
							<td>Attacker sends a version older than the most recent one available (may be newer than the currently installed one).</td>
							<td>Expiration timestamp in the manifest (signed)</td>
						</tr>
						<tr>
							<td>Freeze attack</td>
							<td>Attacker serves outdated information and withholds updates without the device being aware.</td>
							<td>Expiration timestamp in the manifest (signed)</td>
						</tr>
						<tr>
							<td>Extraneous dependency attack</td>
							<td>Attacker inserts additional dependencies to make the device download unwanted (malicious) data.</td>
							<td>Dependency list in the manifest (signed)</td>
						</tr>
						<tr>
							<td>Endless data attack</td>
							<td>Attacker sends endless data instead of the requested manifest or image.</td>
							<td>Image size in the manifest (signed)</td>
						</tr>
						<tr>
							<td>Read attack</td>
							<td>Attacker reads update traffic and may use the captured image for reverse-engineering.</td>
							<td>Optional encryption</td>
						</tr>
				</table>

				<p>Replay attacks using an outdated version are generally detected using the version number included in the update metadata.
				The mechanism described by Frisch et al. installs any version that differs from the currently installed one, even if it is older because they trust that an attacker will not gain access to their update release system.
				Uptane, UpKit, FiGaRo and <a href="#acr-suit">SUIT</a> as well as the mechanism described by Schmidt et al. require the version number to be newer than the currently installed version to mitigate replay attacks.
				Rollbacks are also possible, but they require the rerelease of an older version using a new version number. For this reason, <a href="#acr-suit">SUIT</a> calls it a “monotonic sequence number”, not a version number, and suggests the usage of UNIX timestamps.
				<a href="#acr-tuf">TUF</a> and its derivatives can also prevent the installation of an outdated version by removing it from the <code>targets.txt</code>.</p>

				<p>Uptane, ASSURED, UpKit, FiGaRo and <a href="#acr-suit">SUIT</a> also include targeting information such as device class ID or serial number in the update metadata to mitigate replay attacks using updates meant for another device.</p>

				<p>In special cases, an attacker may replay an update that is newer than the currently installed version, but older than the most recent one available.
				FiGaRo as well as the mechanisms described by Frisch et al. and Schmidt et al. will install this update.
				UpKit and <a href="#acr-suit">SUIT</a> are able to mitigate this attack using two different mechanisms, as described before. UpKit uses nonces that are generated by the device for a specific update request, while <a href="#acr-suit">SUIT</a> uses expiration timestamps in the manifest.
				Nonces have the downside of being difficult to generate with a sufficient level of randomness&nbsp;<a href="#rfc4086">[64]</a>, while expiration timestamps require that a secure time source is available.
				Uptane includes a proposal for a secure time server suitable for embedded devices, however, it also uses nonces.</p>

				<p><a href="#acr-suit">SUIT</a>'s optional expiration timestamp also allows a device to detect freeze attacks if all manifests that are still valid are republished with a new timestamp whenever they expire and the attacker has not compromised the signing key,
				similar to how TUF and its derivatives detect freeze attacks by the expiration of the metadata files.</p>

				<p>Extraneous dependency attacks only affect the mechanisms which support dependencies, which are <a href="#acr-tuf">TUF</a>, Uptane, ASSURED and <a href="#acr-suit">SUIT</a>.
				All of them mitigate against them by signing the dependency lists, which are included in the <code>targets.txt</code> and update manifest, respectively.</p>

				<p><a href="#acr-tuf">TUF</a>, Uptane, ASSURED and <a href="#acr-suit">SUIT</a> and the mechanism described by Schmidt et al. can mitigate endless data attacks concerning the software image using the update file size which is included in the signed metadata.
				To mitigate endless data attacks on the metadata, a cap could be placed on the maximum metadata size that the device wants to receive, as suggested by Cappos et al.&nbsp;<a href="#cappos2008look">[51]</a>. If the cap is exceeded, the device would abort the download.</p>

				<h4>Suitability for Constrained <a href="#acr-iot">IoT</a> Devices</h4>

				<p>As described before, <a href="#acr-tuf">TUF</a> is the only one of the surveyed mechanisms that is not especially suitable for constrained devices.
				All others are suitable in principle, but for all except <a href="#acr-suit">SUIT</a>, no comprehensive evaluation of the resource usage of the update process is available.</p>

				<p><a href="#acr-suit">SUIT</a>'s implementation in RIOT has been evaluated by Zandberg et al. using three different off-the-shelf <a href="#acr-iot">IoT</a> devices with Arm Cortex M microcontrollers (M0+, M3, and M4), between 32&nbsp;kB and 256&nbsp;kB of <a href="#acr-ram">RAM</a>, and between 256&nbsp;kB and 1&nbsp;MB of flash memory&nbsp;[<a href="#rfc8240">46</a>, <a href="#zandberg2019secure">47</a>].
				They compare the memory usage (of <a href="#acr-ram">RAM</a> and flash memory) of a baseline configuration of a <a href="#acr-coap">CoAP</a> server without firmware update support to two different configurations with firmware update support using <a href="#acr-suit">SUIT</a>.
				The first configuration uses <a href="#acr-suit">SUIT</a> over the <a href="#acr-iot">IoT</a> network stack consisting of <a href="#acr-coap">CoAP</a>, <a href="#acr-udp">UDP</a>, <a href="#acr-ipv6">IPv6</a>/<a href="#acr-6lowpan">6LoWPAN</a> and IEEE&nbsp;802.15.4. The second configuration additionally uses the device management protocol <a href="#acr-lwm2m">LwM2M</a> v1.0 on top of <a href="#acr-coap">CoAP</a>,
				which can be used e.g. to provision time information to devices.
				In total, the <a href="#acr-suit">SUIT</a> configuration requires approximately 121&nbsp;kB of flash memory and 20&nbsp;kB of <a href="#acr-ram">RAM</a>.
				The comparison shows this represents an overhead of approximately 16&nbsp;kB of flash memory and 5&nbsp;kB of <a href="#acr-ram">RAM</a> compared to the baseline configuration.
				However, the increase of memory requirements may not be as large for all use cases, because some of the components used by <a href="#acr-suit">SUIT</a> such as <a href="#acr-cbor">CBOR</a> and <a href="#acr-cose">COSE</a> may already be part of some <a href="#acr-iot">IoT</a> applications.
				Additionally, if the two-slot setup is used, flash memory is required for that also.</p>

				<p>Furthermore, Zandberg et al. measure and analyse the total time spent on a full firmware update. They state that a majority of the total time is spent on network transfer (60&nbsp;%) and signature verification (38&nbsp;%), while all other tasks, e.g. parsing of the manifest, take only a negligible amount of time.
				Considering that approximately half of the firmware image's size is due to the cryptographic libraries that must be included for signature verification, they conclude that 68&nbsp;% of the total update duration are caused by the signature verification.
				The choice of the cryptographic library used is therefore very important for the resulting firmware update speed.</p>

				<h4>Minimal User Interaction</h4>

				<p>In all surveyed mechanisms, updates can proceed fully without user interaction.
				<a href="#acr-suit">SUIT</a> additionally supports optional user confirmation before a device proceeds with the installation of an update by including a user authorization condition in the manifest&nbsp;<a href="#ietf-suit-manifest-12">[14, p.&nbsp;60]</a>.</p>

				<h4>Targeting Subsets of Devices</h4>

				<p>In Uptane, the custom metadata fields can be used to limit updates to certain devices. When a vehicle polls the director for available updates, it includes its vehicle ID, which can be used to look up which ECUs are installed in the device. The director is then responsible for forwarding the compatible updates.
				In ASSURED, the process is very similar. The controller communicates with the software repository and performs the <a href="#acr-tuf">TUF</a> validation steps on the received update files as well as checks local targeting rules. If all checks are valid, the update is forwarded to the appropriate devices.</p>

				<p>As described before, FiGaRo supports very flexible targeting using fully custom node attributes, e.g. device class.</p>

				<p><a href="#acr-suit">SUIT</a> also allows the specification of custom conditions&nbsp;<a href="#ietf-suit-manifest-12">[14, p.&nbsp;60]</a>.
				Updates can be limited to subsets of devices by including conditions in the manifest, e.g. that the vendor ID, device class ID or device ID of the device that receives the manifest must match a given ID&nbsp;<a href="#ietf-suit-manifest-12">[14, p.&nbsp;58]</a>.
				Similarly, UpKit supports targeting using the application ID and hardware platform ID fields in the update manifest.</p>

				<h4>Monitoring</h4>

				<p>In the mechanism described by Frisch et al., devices publish their state information such as the currently installed version on a well-known <a href="#acr-mqtt">MQTT</a> topic after a reboot.</p>

				<p>Monitoring is a central part of <a href="#acr-suit">SUIT</a> in the form of the status tracker server.
				However, <a href="#acr-suit">SUIT</a> does not define specifically how and what should be monitored. This decision is left to the implementer. Existing protocols such as <a href="#acr-lwm2m">LwM2M</a> may be used.</p>

				<p>Similarly, in ASSURED, the controller receives a status update from the device once the update is complete.</p>

				<h4>Partial or Differential Updates</h4>

				<p>Partial updates are a central feature of FiGaRo, as described before. Software is divided into components, which can be updated separately using dynamic linking.</p>

				<p><a href="#acr-suit">SUIT</a> supports both partial and differential updates.
				For differential updates, a list of required image versions must be included in the manifest to ensure that the correct base version is present before downloading the differential update. The hash digest of the base image must also be included in the manifest of the differential update and it must be checked using a condition before installation&nbsp;<a href="#ietf-suit-information-model-11">[15, p.&nbsp;10]</a>.</p>

				<h3>Conclusion</h3>

				<p>When comparing how the surveyed update mechanisms fulfil the requirements listed in <a href="#sec-requirements">Section&nbsp;3.2</a>, some common features can be identified.
				All of them include metadata such as the version, file size and dependency lists with the update image.
				All except FiGaRo, which focuses on enabling partial updates rather than security, use cryptographic signatures to authenticate and check the integrity of update images and metadata.
				All except FiGaRo and <a href="#acr-tuf">TUF</a>, which is not designed for constrained devices, support a two-slot system for storing firmware update images to memory while retaining the previously installed version as a fallback.</p>

				<p>The design of <a href="#acr-tuf">TUF</a>, which requires the usage of at least four different signing keys, differs the most from <a href="#acr-suit">SUIT</a>.
				<a href="#acr-tuf">TUF</a> is similarly comprehensive and includes mitigation strategies for a variety of attacks, but it is not suitable for constrained devices. Of <a href="#acr-tuf">TUF</a>'s derivatives, Uptane is highly tailored to the automotive use case, while ASSURED is applicable to the general <a href="#acr-iot">IoT</a> use case.
				The main difference between ASSURED and <a href="#acr-suit">SUIT</a> is that in ASSURED, the controller component interfaces with the software repository on behalf of the <a href="#acr-iot">IoT</a> device, while in <a href="#acr-suit">SUIT</a>, the device itself interfaces with the firmware server.
				In ASSURED, the controller makes the decision which updates to install when. When the controller pushes an update to the device, it is already considered to be approved and the device is expected to install it immediately after performing basic integrity and authenticity checks.
				In <a href="#acr-suit">SUIT</a>, the conditions under which an update should be fetched and installed are specified in the manifest and the device itself evaluates them to determine how it should proceed.</p>

				<p>The design of UpKit is most similar to <a href="#acr-suit">SUIT</a>.
				However, <a href="#acr-suit">SUIT</a> defines a more general and flexible metadata format than UpKit with optional support for dependencies, partial updates and update encryption, for example.
				Additionally, <a href="#acr-suit">SUIT</a> requires the validation of only a single signature, while UpKit always requires the validation of two signatures. This is a significant difference because the transmission and validation of signatures is expensive, as the evaluation by Zandberg et al. showed.</p>

				<p>Overall, <a href="#acr-suit">SUIT</a> is a comprehensive framework for software updates for constrained devices.
				When compared to other update mechanisms, it does not lack any features.
				The manifest format, especially the command sequences that specify all steps of the fetching, validation and installation process as well as the conditions for installation, makes <a href="#acr-suit">SUIT</a> flexible, so that it can be used in various different use cases.
      </section>
      
      <section id="chapter4" class="chapter" data-chapter-num="4">
      	<header>
      		<p class="chapter-num"></p>
		      <h1><a href="#chapter4">Thesis Contribution: A New Transport Mechanism for SUIT Using MQTT-SN</a></h1>
        </header>

				<p>In this chapter, we present the main contribution of this thesis, which is the design and implementation of <a href="#acr-mqttsn">MQTT-SN</a> as a new transport mechanism for <a href="#acr-suit">SUIT</a> in RIOT.</p>

				<h2 id="sec-design"><a href="#sec-design">Design</a></h2>

				<p>In this section, we discuss the considerations and decisions made during the design phase.</p>

				<h3 id="sec-design-app-layer-prot">Choice of Application Layer Protocol</h3>

				<p>Firstly, we must decide which application layer protocol to chose for our new transport mechanism. We consider <a href="#acr-mqtt">MQTT</a> and <a href="#acr-mqttsn">MQTT-SN</a> as options.
				As discussed in <a href="#sec-app-layer-comp">Section&nbsp;2.4</a>, both of them offer advantages:
				<a href="#acr-mqttsn">MQTT-SN</a> is more suitable for wirelessly connected constrained devices and is therefore first choice for our <a href="#acr-iot">IoT</a> use case.
				Its major limiting factor is that it is currently not as widely used and well-supported as <a href="#acr-mqtt">MQTT</a>.
				For Linux systems, there are only very few <a href="#acr-mqttsn">MQTT-SN</a> server implementations available, none of which are widely used and most are not actively maintained.
				However, on RIOT, there are actually two suitable <a href="#acr-mqttsn">MQTT-SN</a> client implementations available.
				This may be due to RIOT's popularity with researchers, who are interested in <a href="#acr-mqttsn">MQTT-SN</a>
				due to its advantages over <a href="#acr-mqtt">MQTT</a>,
				even if it is not widely used in practice.
				Thus, we choose to implement <a href="#acr-mqttsn">MQTT-SN</a> as a new transport mechanism for <a href="#acr-suit">SUIT</a>.</p>

				<h3 id="sec-design-transport">Design of the Transport Mechanism</h3>

				<p>When designing the new transport mechanism using <a href="#acr-mqttsn">MQTT-SN</a>, we must consider <a href="#acr-suit">SUIT</a>'s distinct requirements.
				They differ from the most common use case for <a href="#acr-mqttsn">MQTT-SN</a>, i.e. the transfer of sensor data, in three ways:</p>

				<p>Firstly, the size of the data units that must be transferred during a firmware update (i.e. the manifest and the image) is much larger than the size of a sensor data unit (e.g. a temperature reading).
				Unlike a sensor data unit, the firmware update data cannot be transferred in a single <span class="sc">Publish</span> message.
				The message's size would exceed the size of the receive buffer in the <a href="#acr-iot">IoT</a> device's <a href="#acr-ram">RAM</a>.
				Therefore, the update data must be transferred in blocks; however, there is no feature like <a href="#acr-coap">CoAP</a>'s block-wise transfer built into <a href="#acr-mqtt">MQTT</a> or <a href="#acr-mqttsn">MQTT-SN</a>.
				Therefore, it must somehow be implemented by the application itself.</p>

				<p>Secondly, the duration for which an update manifest and image are valid is much longer than the timespan during which a sensor data unit is valid. While sensor data readings may become outdated and be replaced by an updated reading quite frequently, e.g. multiple times per hour, the update manifest and image may be replaced by a newer version much less frequently.
				Still, the update manifest and image should only need to be published to the broker once when they first become available.
				Afterwards, the broker should keep them in storage and behave similarly to a file server.</p>

				<p>Thirdly, the update manifest and image remain valid even if a newer version is available, whereas an older sensor reading is generally made obsolete by a newer reading. The broker will no longer serve the older sensor reading to publishers. To support software downgrades, the broker should however still serve older update images.</p>

				<p>To fulfil these requirements, we use the <span class="sc">Retain</span> flag when publishing the update data (see <a href="#sec-background-mqtt">Section&nbsp;2.2</a>). This causes the <a href="#acr-mqtt">MQTT</a> broker to store it and send it to all future subscribers immediately upon subscription. This way, <a href="#acr-iot">IoT</a> devices can request a download of the manifest and image by subscribing to the corresponding topics (see <a href="#fig-suit-flow-mqtt">Figure&nbsp;7</a>).
				Since there can only be one retained message on a topic at a time, we must publish each version and each block on a separate topic.
				To separate images compiled for different device classes, we may also include the device class ID in the topic name, e.g. <code>suit/images/v2.0/f767zi/0</code>.
				To ensure a long-term storage, we additionally set the <a href="#acr-qos">QoS</a> level to 1, since a retained message with <a href="#acr-qos">QoS</a> level 0 may be deleted by the broker at any time.
				Using <a href="#acr-qos">QoS</a> level 2 is not necessary since the device can keep track of which blocks it has already received, and discard duplicate blocks. <a href="#acr-qos">QoS</a> level 2 would only increase the control overhead unnecessarily by tripling the number of acknowledgements per block.</p>

				<p>To reduce the number of subscriptions necessary, wildcard subscriptions could be used.
				For example, the <a href="#acr-iot">IoT</a> device may subscribe to the wildcard topic <code>suit/images/v2.0/f767zi/\#</code> (which includes the subtopics ending in <code>/0</code>, <code>/1</code>, <code>/2</code>,...) to receive all retained block messages.
				However, this would not lower the amount of control traffic. A topic ID must be registered for each of the subtopics. Without a wildcard subscription, the topic IDs are included in the <span class="sc">SubAck</span>s. With a wildcard subscription, a <span class="sc">Register</span> and <span class="sc">RegAck</span> message must be sent for each subtopic.
				Since the sizes of these control message types are very similar, the amount of control traffic is basically the same in both cases.
				Additionally, we must also consider the issue of message order.
				According to the <a href="#acr-mqtt">MQTT</a> protocol specification, the broker must forward messages published with <a href="#acr-qos">QoS</a> level >0 to subscribers in the order that they were published in&nbsp;<a href="#mqtt-5.0">[25, pp.&nbsp;97&nbsp;f.]</a>.
				However, it does not specify in what order the broker should forward messages published on topics matching a wildcard subscriptions.
				(At the time of writing, the Mosquitto broker also uses publish-order for these messages (with the exception of the parent topic), however, this may change at any time. See <a href="https://www.eclipse.org/lists/mosquitto-dev/msg02463.html">here</a>.)
				Therefore, the implementation cannot assume that the blocks arrive in any kind of order when wildcard subscriptions are used.
				This poses a problem because typical flash memory hardware interfaces first set all bits during erase operations and then only unset certain bits during write operations.
				This makes writing to flash memory in random order impractical, unless all of the writes are multiples of the page size in length as well as page-aligned.
				Thus, RIOT's APIs only support in-order write access to the flash memory.
				Out-of-order blocks would need to be buffered in <a href="#acr-ram">RAM</a> before they can be written to flash memory. However, in the worst case, the blocks arrive in reverse order, which would require almost the entire firmware image to be buffered in <a href="#acr-ram">RAM</a>. This is clearly not feasible.
				Additionally, neither of the <a href="#acr-mqttsn">MQTT-SN</a> client implementations in RIOT actually support wildcard subscriptions at the time of writing.
				Therefore, we decide against the usage of wildcard subscriptions.</p>

				<figure id="fig-suit-flow-mqtt">
					<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-0.5 -0.5 616 431"><defs></defs><g><rect x="0" y="0" width="100" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 50 40 L 50 100" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="17" y="5" width="67" height="32" stroke-width="0"/><text x="49.5" y="17">Firmware</text><text x="49.5" y="33">Author</text></g><rect x="45" y="70" width="10" height="20" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><rect x="140" y="0" width="140" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 210 40 L 210 430" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="148" y="5" width="126" height="32" stroke-width="0"/><text x="209.5" y="17">Firmware Server</text><text x="209.5" y="33">(MQTT-SN Broker)</text></g><path d="M 55.1 70.12 L 196.88 70.01" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 203.88 70 L 196.88 73.51 L 196.88 66.51 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><text x="129.61" y="68.56">MQTT PUBLISH</text><text x="129.61" y="82.56">RETAIN=1, QoS=1</text><text x="129.61" y="96.56">Firmware + Manifest</text></g><rect x="300" y="0" width="100" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 350 40 L 350 120" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="301" y="5" width="100" height="32" stroke-width="0"/><text x="349.5" y="17">Status Tracker</text><text x="349.5" y="33">Server</text></g><rect x="345" y="90" width="10" height="30" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><rect x="450" y="0" width="100" height="40" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 500 40 L 500 430" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="13px"><rect fill="#ffffff" stroke="none" x="465" y="13" width="72" height="17" stroke-width="0"/><text x="499.5" y="25">IoT Device</text></g><rect x="495" y="70" width="10" height="350" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 214.97 150.3 L 487.13 150.2" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 494.13 150.2 L 487.13 153.7 L 487.13 146.7 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><text x="354.47" y="148.75">MQTT-SN PUBLISH</text><text x="354.47" y="162.75">suit/trigger suit/man/...</text></g><path d="M 495.12 273.82 L 223.65 273.96" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 216.65 273.96 L 223.65 270.46 L 223.65 277.46 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><text x="359.62" y="269.39">MQTT-SN PUBACK</text></g><path d="M 505.4 299.73 L 530 300 L 530 310 L 513.57 310.08" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 506.57 310.11 L 513.55 306.58 L 513.59 313.58 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="12px"><rect fill="#ffffff" stroke="none" x="535" y="289" width="55" height="30" stroke-width="0"/><text x="535.15" y="300.5">Validate</text><text x="535.15" y="314.5">manifest</text></g><path d="M 215 256.02 L 486.9 255.85" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 493.9 255.84 L 486.9 259.35 L 486.9 252.35 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="#ffffff" stroke="none" x="257" y="239" width="207" height="15" stroke-width="0"/><text x="359.5" y="250.43">MQTT-SN PUBLISH suit/man/.../0</text></g><path d="M 494.89 187.01 L 223.04 187.1" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 216.04 187.1 L 223.04 183.6 L 223.04 190.6 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="#ffffff" stroke="none" x="291" y="171" width="119" height="15" stroke-width="0"/><text x="349.39" y="181.56">MQTT-SN PUBACK</text></g><path d="M 505.4 406.73 L 530 407 L 530 417 L 513.57 417.08" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 506.57 417.11 L 513.55 413.58 L 513.59 420.58 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" font-size="12px"><rect fill="#ffffff" stroke="none" x="534" y="396" width="82" height="30" stroke-width="0"/><text x="534.1" y="407.5">Procced with</text><text x="534.1" y="421.5">installation</text></g><path d="M 495.13 82.95 L 223.19 83.29" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 216.19 83.3 L 223.18 79.79 L 223.19 86.79 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="#ffffff" stroke="none" x="249" y="67" width="214" height="15" stroke-width="0"/><text x="354.62" y="77.62">MQTT-SN SUBSCRIBE suit/trigger</text></g><path d="M 495.05 219.88 L 222.8 219.61" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 215.8 219.6 L 222.8 216.11 L 222.79 223.11 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="#ffffff" stroke="none" x="247" y="203" width="228" height="15" stroke-width="0"/><text x="359.55" y="214.25">MQTT-SN SUBSCRIBE suit/man/.../#</text></g><rect x="205" y="70" width="10" height="350" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><path d="M 344.89 104.93 L 223.16 105.09" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 216.16 105.1 L 223.15 101.59 L 223.16 108.59 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="10px"><text x="284.38" y="102.52">MQTT PUBLISH</text><text x="284.38" y="114.52">suit/trigger suit/man/...</text></g><path d="M 487 293.82 L 223.65 293.96" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 494 293.82 L 487 297.32 L 487 290.32 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><path d="M 216.65 293.96 L 223.65 290.46 L 223.65 297.46 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><text x="359.62" y="288.39">(Repeat until all blocks are transferred)</text></g><path d="M 495.12 382.82 L 223.65 382.96" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 216.65 382.96 L 223.65 379.46 L 223.65 386.46 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="#ffffff" stroke="none" x="301" y="366" width="119" height="15" stroke-width="0"/><text x="359.62" y="377.39">MQTT-SN PUBACK</text></g><path d="M 215 364.02 L 486.9 363.85" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 493.9 363.84 L 486.9 367.35 L 486.9 360.35 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="#ffffff" stroke="none" x="262" y="347" width="196" height="15" stroke-width="0"/><text x="359.5" y="358.43">MQTT-SN PUBLISH suit/fw/.../0</text></g><path d="M 495.05 327.88 L 222.8 327.61" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 215.8 327.6 L 222.8 324.11 L 222.79 331.11 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><rect fill="#ffffff" stroke="none" x="253" y="311" width="216" height="15" stroke-width="0"/><text x="359.55" y="322.25">MQTT-SN SUBSCRIBE suit/fw/.../#</text></g><path d="M 487 402.82 L 223.65 402.96" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 494 402.82 L 487 406.32 L 487 399.32 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><path d="M 216.65 402.96 L 223.65 399.46 L 223.65 406.46 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><text x="359.62" y="397.39">(Repeat until all blocks are transferred)</text></g><path d="M 487 236.82 L 215.53 236.96" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 494 236.82 L 487 240.32 L 487 233.32 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><text x="359.62" y="232.39">MQTT-SN SUBACK</text></g><path d="M 487 344.82 L 215.53 344.96" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 494 344.82 L 487 348.32 L 487 341.32 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g fill="rgb(0, 0, 0)" font-family="Georgia, serif" text-anchor="middle" font-size="12px"><text x="359.62" y="340.39">MQTT-SN SUBACK</text></g></g></svg>
					<figcaption>Sequence diagram of a software update using <a href="#acr-suit">SUIT</a> with a push notification and <a href="#acr-mqttsn">MQTT-SN</a> as the transport mechanism: The status tracker server pushes an update trigger to the device using a <span class="sc">Publish</span> message. The device then downloads manifest and image by subscribing to the block topics one by one and receiving each block as a retained <span class="sc">Publish</span> message.</figcaption>
				</figure>

				<p>It must be noted that our design using retained messages has one major disadvantage when compared to <a href="#acr-coap">CoAP</a>: We cannot support variable block sizes as easily, because the block size must be fixed prior to the initial publishing. If multiple block sizes are required, the update manifest and image must be uploaded multiple times using different block sizes.
				However, software updates are only expected to work on devices of the same class, e.g. devices that have identical hardware. Thus, multiple different block sizes may not be needed, since a single block size can already provide a good match for the capacities of all targeted devices.</p>

				<h2 id="sec-implementation"><a href="#sec-implementation">Implementation</a></h2>

				<p>To run <a href="#acr-suit">SUIT</a> on a RIOT device, the modules <code>riotboot</code> and <code>suit</code> are required.
				The module <code>riotboot</code> is a bootloader that partitions the device's flash memory into three sections: The first section contains the bootloader itself, and the second and third sections are firmware slots. Thus, two firmwares can be stored in flash memory at the same time. One slot is active, i.e. it is used during device boot-up. The inactive slot is used to store the newly downloaded firmware image during the update process.
				At the start of each firmware slot, the <code>riotboot</code> header is stored. It contains four 4&nbsp;B long values: a magic number (“RIOT” in ASCII), the firmware version version, the start address of the actual firmware, and a checksum of the header. (See <a href="https://github.com/RIOT-OS/RIOT/blob/010dbcc9d3ff2890b3da2cb8926cb6ef7df2874d/bootloaders/riotboot/doc.txt">here</a>.)
				The module <code>suit</code> contains the <a href="#acr-suit">SUIT</a>-related functionality, e.g. the different transport mechanisms. Currently, there is only one transport mechanism that is implemented, which uses <a href="#acr-coap">CoAP</a>.
				In this section, we describe the implementation of the new transport mechanism using <a href="#acr-mqttsn">MQTT-SN</a>.</p>

				<h3 id="sec-choice-mqtt-sn-impl">Choice of MQTT-SN Implementations</h3>

				<p>Firstly, we discuss our choices of <a href="#acr-mqttsn">MQTT-SN</a> implementations both on the client and on the server side.</p>

				<h4>Client Implementation</h4>

				<p>As mentioned in <a href="#sec-design-app-layer-prot">Section&nbsp;4.1.1</a>, RIOT offers two different <a href="#acr-mqttsn">MQTT-SN</a> client implementations: <code>emcute</code> and <code>asymcute</code>.
				The main difference between them is that <code>emcute</code> offers synchronous (blocking) functions, while  <code>asymcute</code> offers asynchronous (non-blocking) functions.
				For example, consider how the two libraries implement the <span class="sc">Subscribe</span> request:
				The function <code>emcute_sub</code> returns only after the request is completed, either due to a server response or a timeout.
				In contrast, the function <code>asymcute_subscribe</code> returns as soon as the request has been sent, and a user-provided callback function is called when the response is received or the request has timed out.
				Internally, <code>asymcute</code> uses asynchronous <a href="#acr-udp">UDP</a> <a href="https://riot-os.org/api/group__net__sock__async__event.html">sockets that use an event loop to handle incoming messages and timeouts</a>.</p>

				<p>Its asynchronous design allows <code>asymcute</code> to support multiple simultaneously outstanding requests, e.g. <span class="sc">Publish</span>es or <span class="sc">Subscribe</span>s.
				Each outstanding request is associated with its own request context data structure including a transmit buffer.
				In contrast, <code>emcute</code> uses only one global transmit buffer.
				For applications which make heavy use of requests originating at the <a href="#acr-iot">IoT</a> device, this can be a major performance advantage.
				However, these performance gains come with increased memory usage.
				A comparison of the memory usage of the two implementations shows that <code>asymcute</code> uses around 3.2&nbsp;kB more flash memory and around 0.2&nbsp;kB more <a href="#acr-ram">RAM</a> than <code>emcute</code>. (See <a href="https://github.com/vera/masters-thesis/blob/master/results/asymcute_emcute_comparison/2021-02-19-memory-usage-asymcute-vs-emcute.txt">here</a>.)
				The increased memory usage is due to a larger code size caused by the library functions and the asynchronous sockets and slightly larger data structures used.</p>

				<p>In our firmware update application, the device frequently sends <span class="sc">Subscribe</span> requests (one for each block topic, see <a href="#fig-suit-flow-mqtt">Figure&nbsp;7</a>), but since the blocks must be received in-order, each <span class="sc">Subscribe</span> must be completed before the next one can be sent.
				To allow the device to send multiple <span class="sc">Subscribe</span>s at once, potential out-of-order blocks would need to be handled, which would complicate the transport logic and would require an additional memory buffer.
				Therefore, <code>asymcute</code> does not appear to promise better performance than <code>emcute</code> that would justify the increased memory usage, which makes
				<code>emcute</code> the better choice for our application.</p>

				<h4>Server Implementation</h4>

				<p>When choosing the <a href="#acr-mqttsn">MQTT-SN</a> server implementation used, we consider the following two options:
				the <a href="https://github.com/eclipse/mosquitto.rsmb">RSMB</a>
				and the <a href="https://github.com/eclipse/paho.mqtt-sn.embedded-c/tree/master/MQTTSNGateway">Eclipse Paho MQTT-SN Gateway</a> implementation.
				Both are open-source projects at the Eclipse Foundation.</p>

				<p>The <a href="#acr-rsmb">RSMB</a> was developed at IBM and initially released as closed-source. The widely known Mosquitto broker
				was developed as an open-source alternative to it.
				The <a href="#acr-rsmb">RSMB</a> was eventually contributed to Eclipse as open-source in 2013, but it is no longer being actively developed and can now be considered deprecated.
				In its feature set, it is largely inferior to Mosquitto, which has a large user base and is being actively maintained.
				The only major advantage of <a href="#acr-rsmb">RSMB</a> is its <a href="#acr-mqttsn">MQTT-SN</a> support, which Mosquitto and basically all other <a href="#acr-mqtt">MQTT</a> brokers lack.</p>

				<p>The Paho <a href="#acr-mqttsn">MQTT-SN</a> Gateway is a standalone gateway that translates between <a href="#acr-mqttsn">MQTT-SN</a> and <a href="#acr-mqtt">MQTT</a>, which means that it must be used in combination with an <a href="#acr-mqtt">MQTT</a> broker (as seen in <a href="#fig-mqtt-sn-arch">Figure&nbsp;4</a>). This is a major advantage over the <a href="#acr-rsmb">RSMB</a>, because it allows us to combine it with an up-to-date broker implementation such as Mosquitto.</p>

				<p>Therefore, we initially tested the Paho <a href="#acr-mqttsn">MQTT-SN</a> Gateway and the Mosquitto <a href="#acr-mqtt">MQTT</a> broker in combination. However, the Paho Gateway appeared to be lacking in maturity and suffered from several bugs (see <a href="#appendix2">Appendix&nbsp;2</a>). It also achieved much worse total update durations in preliminary tests than the <a href="#acr-rsmb">RSMB</a>.
				Therefore, we decide to use the <a href="#acr-rsmb">RSMB</a> to obtain the best possible evaluation results.</p>

				<h3 id="sec-implementation-details">Implementation of the Transport Mechanism</h3>

				<p>To add the transport mechanism using <a href="#acr-mqttsn">MQTT-SN</a> to RIOT's <a href="#acr-suit">SUIT</a> implementation, we firstly add a tool that allows easy publishing of new firmware images and manifests.
				For the <a href="#acr-coap">CoAP</a> transport mechanism, the <code>make</code> target <code>suit/publish</code> does this by simply copying the manifest and firmware files to the folder that is being served by <a href="https://aiocoap.readthedocs.io/en/latest/module/aiocoap.cli.fileserver.html"><code>aiocoap-fileserver</code></a>. This makes the files available for retrieval using <a href="#acr-coap">CoAP</a> <span class="sc">Get</span>.
				For the <a href="#acr-mqttsn">MQTT-SN</a> transport mechanism, we implement a Python program for the same purpose. The program receives a file path, block size and topic prefix as input parameters (among others) and performs a block-wise publishing of the file to the subtopics <code>&lt;PREFIX&gt;/0</code>, <code>&lt;PREFIX&gt;/1</code>, <code>&lt;PREFIX&gt;/2</code>, and so on.
				It additionally publishes the total number of blocks to the parent topic <code>&lt;PREFIX&gt;</code>. This information is used by the <a href="#acr-iot">IoT</a> device to know how many blocks to expect.
				It can also be used by the publishing program to delete previous retained blocks. This may be necessary when a file is published under an already used topic prefix but the number of blocks has decreased, either because the new file is smaller or because a larger block size is used. If the excess blocks were not deleted, they would be needlessly transmitted to all subscribing <a href="#acr-iot">IoT</a> devices from then on.</p>

				<p>Secondly, we implement the actual transport mechanism. As shown in <a href="#fig-suit-flow-mqtt">Figure&nbsp;7</a>, it involves mainly the handling of incoming <span class="sc">Publish</span> messages on the trigger, update manifest and image topics.
				For the initial connection setup, we add two new shell commands: <code>con &lt;ipv6 addr&gt; [port]</code> for connecting to an <a href="#acr-mqttsn">MQTT-SN</a> gateway and <code>sub &lt;topic name&gt;</code> for subscribing to a trigger topic.
				Ideally, a connection to an available gateway should be automatically established using gateway discovery (see <a href="#sec-background-mqtt-sn">Section&nbsp;2.3</a>), but this is not supported by <code>emcute</code>.
				It would also require some additionally security mechanisms such as the usage of <a href="#acr-dtls">DTLS</a> to authenticate the gateways. If the gateway discovery process is not secured, any malicious server could announce itself using <span class="sc">GwInfo</span> messages and start serving invalid manifests or firmware images to execute resource exhaustion attacks.
				For monitoring, the device automatically publishes messages on three device status topics <code>suit/version/&lt;DEVICE_ID&gt;</code> (for the current firmware version), and <code>suit/slot/[in]active/&lt;DEVICE_ID&gt;</code> (for the indices of the currently active and inactive firmware slots) once it is connected to a gateway.
				For the handling of incoming <span class="sc">Publish</span> messages, we implement three different handler functions:</p>

				<p>Firstly, there is the handler for <span class="sc">Publish</span>es on the trigger topic. These messages contain a manifest topic prefix. The device subscribes to the topic name contained in the payload and then to its subtopics <code>/0</code>, <code>/1</code>, <code>/2</code>,... to receive the number of manifest blocks as well as the blocks themselves, as described in <a href="#sec-design-transport">Section&nbsp;4.1.2</a>.</p>

				<p>Secondly, there is the handler for <span class="sc">Publish</span>es on the manifest topic. These messages contain either the total number of blocks to be expected or a block of the manifest, as described above. The manifest blocks are copied to a 640&nbsp;B buffer, which is large enough to hold an entire manifest, with an offset depending on the block number. If the final block has been transmitted, <code>suit_parse</code> is called on the manifest, which starts the validation of the manifest as described in <a href="#sec-rw-suit">Section&nbsp;3.3.1</a>, and if all checks are successful, the command sequences are executed, which usually contain a “fetch” command for the update image.</p>

				<p>We extend the <a href="#acr-suit">SUIT</a> fetch command handler to handle manifest <a href="#acr-uri">URIs</a> beginning with <code>mqtt://</code> followed by a topic name. (This is not an official <a href="#acr-uri">URI</a> scheme. Currently, no <a href="#acr-uri">URI</a> schemes for <a href="#acr-mqtt">MQTT</a> or <a href="#acr-mqttsn">MQTT-SN</a> have been officially registered at the <a href="#acr-iana">IANA</a>. A <a href="https://issues.oasis-open.org/browse/MQTT-203">proposal</a> has been discussed by the <a href="#acr-mqtt">MQTT</a> Technical Committee, however, it does not include topic names, which we require here. Therefore, we use this simple unofficial scheme.) The handler calls the fetch function defined by the <a href="#acr-mqttsn">MQTT-SN</a> transport. This fetch function subscribes to the given topic and registers the third handler, which is for <span class="sc">Publish</span>es on the firmware topic. Each firmware block is written to flash memory.
				If fewer bytes or more bytes than the total image size from the manifest are received, the fetch command aborts with an error. Otherwise, further commands (e.g. image hash check) are executed. If successful, the device finally reboots from the new firmware.</p>

				<p>A <code>struct</code> keeps track of the current state of the block-wise transfer (see <a href="#listing-blockwise-struct">Figure&nbsp;8</a>).
				The total number of expected blocks is necessary to know when the final block has been received.
				The number of already correctly received blocks is used to check whether the current received block is in-order, which is necessary because the firmware image must be written to flash memory without gaps, as described above.
				The number and length of the current block are used to calculate the correct offset and number of bytes to write when writing to both flash memory and the manifest buffer in <a href="#acr-ram">RAM</a>.</p>

				<figure id="listing-blockwise-struct">
					<pre><code>
typedef struct {
	uint16_t num_blocks_total;
	uint16_t num_blocks_rcvd;
	uint16_t current_block_num;
	uint16_t current_block_len;
} suit_mqtt_sn_blockwise_t;
					</code></pre>
					<figcaption>The data structure used to keep track of the current state of the block-wise transfer over <a href="#acr-mqttsn">MQTT-SN</a>.</figcaption>
				</figure>

				<p>The source code of the implementation can be found <a href="https://github.com/vera/RIOT/tree/suit/mqtt-sn">on GitHub</a>.</p>

      </section>

      <section id="chapter5" class="chapter" data-chapter-num="5">
      	<header>
      		<p class="chapter-num"></p>
		      <h1><a href="#chapter5">Thesis Outcome: Evaluation and Comparison</a></h1>
        </header>

				<p>In this chapter, we present the evaluation of our implementation.
				The goal of the evaluation is to find out how well the new implementation of the <a href="#acr-mqttsn">MQTT-SN</a> transport mechanism for <a href="#acr-suit">SUIT</a> in RIOT performs, especially in comparison to the existing <a href="#acr-coap">CoAP</a> transport mechanism. For this purpose, we conduct measurements of both variants.</p>

				<h2 id="sec-eval-setup"><a href="#sec-eval-setup">Setup</a></h2>

				<p>In this section, we describe the parameters of our evaluation, such as hardware and software setup used, as well as the metrics that we examined.
				The workload which we evaluate is a full firmware update from start to end as outlined in <a href="#sec-suit-process">Section&nbsp;3.3.1</a>, i.e. from the update trigger followed by transmission of the manifest and the update image until the successful reboot. The full firmware of the <a href="#acr-iot">IoT</a> device is updated.</p>

				<p>We consider four metrics in our evaluation.
				Firstly, we measure both the <a href="#acr-ram">RAM</a> and flash memory requirements of our implementation.
				Secondly, we measure the total traffic volume going over the wireless link during the update. Since we do not vary the protocols used other than on the application layer (<a href="#acr-mqttsn">MQTT-SN</a> or <a href="#acr-coap">CoAP</a>), we can evaluate which protocol causes more overhead.
				Thirdly, we measure the total time required for the full firmware update.
				Finally, we measure the energy consumption of a full firmware update.</p>

				<p>For the time and energy consumption measurements, we use the <a href="#acr-miot-lab">MIoT Lab</a>&nbsp;<a href="#kientopf2019miot">[66]</a>, which is a testbed for <a href="#acr-iot">IoT</a> applications. At the time of writing, it consists of eight testbed nodes, which are positioned in several rooms on two levels of the computer science faculty's building at the Otto von Guericke University Magdeburg.
				The testbed nodes each consist of two commercially available hardware components: an x86 and an embedded device (Nucleo F767ZI).
				See <a href="#tab-eval-parameters">Table&nbsp;3</a> for an overview of the hardware specifications.
				The Nucleo boards are flashed and controlled by the x86 components, which are connected to the testbed management system via Ethernet.
				The boards are equipped with multiple transceivers, e.g. for <a href="#acr-ieee">IEEE</a>&nbsp;802.15.4, <a href="#acr-ieee">IEEE</a>&nbsp;802.11n (Wi-Fi) and sub-GHz communication, and are also connected to the x86 components via Ethernet.
				The testbed nodes are capable of monitoring the power usage of the board and the transceivers separately.
				The testbed uses the DES-Cript experiment description language to store experiment settings to ensure repeatability and reproducibility.</p>

				<table id="tab-eval-parameters">
					<caption>Parameters that influence the results of the evaluation measurements. The parameters that are varied during the evaluation are highlighted.</caption>
					<thead>
						<tr>
							<td>Parameter</td>
							<td>Value(s)</td>
						</tr>
					</thead>
					<tbody>
						<tr class="subhead">
							<td colspan="2">Hardware</td>
						</tr>
						<tr>
							<td>Boards</td>
							<td>Nucleo F767ZI</td>
						</tr>
						<tr>
							<td>...CPU</td>
							<td>ARM Cortex M7 (STM32) @ 216&nbsp;MHz</td>
						</tr>
						<tr>
							<td>...Flash memory</td>
							<td>2&nbsp;MiB</td>
						</tr>
						<tr>
							<td>...<a href="#acr-ram">RAM</a></td>
							<td>512&nbsp;KiB</td>
						</tr>
						<tr>
							<td>...Transceiver</td>
							<td>Atmel AT86RF215</td>
						</tr>
						<tr>
							<td>...Transmit frequency</td>
							<td>2.4&nbsp;GHz</td>
						</tr>
						<tr>
							<td>...Transmit power</td>
							<td>maximum<sup>1</sup></td>
						</tr>
						<tr>
							<td>Power monitoring</td>
							<td>Espressif ESP32 + TI INA3221</td>
						</tr>
						<tr>
							<td><a href="#acr-mqttsn">MQTT-SN</a>/<a href="#acr-coap">CoAP</a> server</td>
							<td>Virtual 4 core CPU @ 2.4&nbsp;GHz, 8&nbsp;GB <a href="#acr-ram">RAM</a></td>
						</tr>
						<tr class="subhead">
							<td colspan="2">Testbed conditions</td>
						</tr>
						<tr>
							<td><a href="#acr-rssi">RSSI</a> between nodes</td>
							<td>77.27&nbsp;dBm</td>
						</tr>
						<tr>
							<td>Other network loads</td>
							<td>low<sup>2</sup></td>
						</tr>
						<tr>
							<td>Other loads on the <a href="#acr-mqttsn">MQTT-SN</a>/<a href="#acr-coap">CoAP</a> server</td>
							<td>none</td>
						</tr>
						<tr class="subhead">
							<td colspan="2">Software</td>
						</tr>
						<tr>
							<td><a href="#acr-iot">IoT</a> <a href="#acr-os">OS</a></td>
							<td>RIOT</td>
						</tr>
						<tr>
							<td>Network stack</td>
							<td>GNRC</td>
						</tr>
						<tr class="hl">
							<td>...Host-to-network layer</td>
							<td>{Ethernet, IEEE&nbsp;802.15.4}</td>
						</tr>
						<tr>
							<td>...Network layer</td>
							<td><a href="#acr-ipv6">IPv6</a> + <a href="#acr-6lowpan">6LoWPAN</a></td>
						</tr>
						<tr>
							<td>...Transport layer</td>
							<td><a href="#acr-udp">UDP</a></td>
						</tr>
						<tr class="hl">
							<td>...Application layer</td>
							<td>{<a href="#acr-mqttsn">MQTT-SN</a>, <a href="#acr-coap">CoAP</a>}</td>
						</tr>
						<tr>
							<td><a href="#acr-mqttsn">MQTT-SN</a> server and client</td>
							<td><a href="#acr-rsmb">RSMB</a> and <code>emcute</code></td>
						</tr>
						<tr>
							<td><a href="#acr-coap">CoAP</a> server and client</td>
							<td><code>aiocoap-fileserver</code> and <code>nanocoap</code></td>
						</tr>
						<tr class="subhead">
							<td colspan="2"><a href="#acr-suit">SUIT</a> configuration parameters</td>
						</tr>
						<tr>
							<td>Size of manifest</td>
							<td>~500&nbsp;B</td>
						</tr>
						<tr>
							<td>Size of firmware image</td>
							<td>85&nbsp;kB</td>
						</tr>
						<tr class="hl">
							<td>Block size</td>
							<td>{32&nbsp;B, 64&nbsp;B, 128&nbsp;B, 256&nbsp;B, 512&nbsp;B}</td>
						</tr>
						<tr class="hl">
							<td>Number of updated devices</td>
							<td>{1, maximum (7)}</td>
						</tr>
					</tbody>
				</table>

				<p><sup>1</sup> Incorrectly reported as 3&nbsp;dBm by RIOT. The true maximum transmit power of the AT86RF215 is 15.5&nbsp;dBm&nbsp;<a href="#at86rf215">[67, p.&nbsp;191]</a>. See <a href="https://forum.riot-os.org/t/changing-the-tx-power-of-the-at86rf215">here</a>.</p>

				<p><sup>2</sup> During the wireless measurements, other radio interference, e.g. by Wi-Fi traffic, was low, since the campus was relatively empty due to the corona virus pandemic and the experiments were conducted in the late evening or night (after 8&nbsp;p.m.).</p>

				<p>Several parameters can be expected to affect the performance of our system, such as other loads on the network or servers or the size of the firmware image being transmitted to the <a href="#acr-iot">IoT</a> devices.
				See <a href="#tab-eval-parameters">Table&nbsp;3</a> for an overview of the relevant parameters.
				We vary only those parameters that we are interested in evaluating. They are highlighted in <a href="#tab-eval-parameters">Table&nbsp;3</a>.
				Firstly and most importantly, we vary the transport mechanism used, i.e. <a href="#acr-coap">CoAP</a> or <a href="#acr-mqttsn">MQTT-SN</a>.
				Secondly, we vary the block size used during transmission to find out which effect it has on our evaluation metrics and which block size performs best.
				Thirdly, we vary the number of devices being updated at the same time to evaluate the scalability of the <a href="#acr-suit">SUIT</a> implementation. At the time of writing, the maximum possible number of nodes usable for these experiments is seven nodes. (One of the eight testbed nodes could not be used due to hard faults that occur at the initial firmware booting, presumably due to problems with the connection to the attached EEPROM.)
				Finally, to better isolate the effects of the parameters being varied, we conduct measurements first over Ethernet, which provides a more stable and reproducible network, and then over wireless radio, which is closer to the real environment in which <a href="#acr-suit">SUIT</a> may be used.
				All other parameters are fixed throughout our evaluation.</p>

				<p>The reasons for the choice of <a href="#acr-mqttsn">MQTT-SN</a> implementations were already discussed in <a href="#sec-design-app-layer-prot">Section&nbsp;4.1.1</a>.
				The <a href="#acr-coap">CoAP</a> implementations were chosen as suggested in the <a href="https://github.com/RIOT-OS/RIOT/blob/80e14e88a10d0795b5d8416edd564bb09f64ae38/examples/suit_update/README.md"><code>README</code></a> of the pre-existing <a href="#acr-suit">SUIT</a> implementation in RIOT.
				For a full list of all software used including version numbers, see <a href="#appendix1">Appendix&nbsp;1</a>.</p>

				<h2 id="sec-eval-methods"><a href="#sec-eval-methods">Methods</a></h2>

				<p>In this section, we describe how we conducted our evaluation, e.g. how the data is gathered and which tools are used to analyse it.
				The raw data, program files, DES-Cript files as well as more detailed descriptions of our methods for the purpose of reproducibility are given on <a href="https://github.com/vera/masters-thesis">GitHub</a>.</p>

				<h3>Memory Usage</h3>

				<p>To evaluate the memory usage of <a href="#acr-suit">SUIT</a> in RIOT, we compile our binaries optimized for code size using the flag <code>-Os</code>, which is standard for RIOT, inside the Docker container <code>riot/riotbuild</code>.
				The binaries are compiled for the testbed boards (Nucleo F767-ZI) and include the modules of the GNRC network stack necessary for wireless communication over IEEE&nbsp;802.15.4.
				We use the C standard library implementation <a href="https://github.com/picolibc/picolibc">Picolibc</a> instead of the default <a href="https://sourceware.org/newlib">Newlib</a> because of its reduced memory footprint.
				Using this setup, the results we achieve for the <a href="#acr-coap">CoAP</a> version are very similar to those reported by Zandberg et al. in their evaluation&nbsp;<a href="#zandberg2019secure">[47]</a>.
				The transmit and receive buffers of <code>emcute</code> are left at the default size of 512&nbsp;B each.</p>

				<p>To determine the <a href="#acr-ram">RAM</a> and flash memory usages of the compiled binaries, we use the binary size profiler
				<a href="https://github.com/google/bloaty">Bloaty</a>.
				Bloaty provides a fine-grained memory usage split down to compile units (i.e. files) or symbols (i.e. function or variable names).
				It also allows the definition of custom categorization using regular expressions that are applied on the compile unit or symbol names. For example, all file paths containing “emcute” can be sorted into the category “mqtt-sn” to obtain the total memory usage related to the <a href="#acr-mqttsn">MQTT-SN</a> component.</p>

				<h3>Network Traffic Volume</h3>

				<p>The network traffic is captured in a local setup of a Nucleo F767-ZI connected to a laptop computer via Ethernet using <a href="https://wireshark.org">Wireshark</a>.
				The resulting capture file is then analysed using a <a href="https://github.com/vera/traffic-analysis">self-written Python program</a>
				which uses <a href="https://github.com/KimiNewt/pyshark">Pyshark</a>, a wrapper for Wireshark's command line equivalent <code>tshark</code>, to dissect the packets and then calculates total for each involved protocol and each packet direction (i.e. server/broker to device or device to server/broker).
				Because the update's network traffic is more or less deterministic when there is no random packet loss, a single capture is sufficient to evaluate the network traffic volume.</p>

				<h3>Total Duration of the Firmware Update and Energy Consumption</h3>

				<p>The duration and energy consumption measurements are run in the <a href="#acr-miot-lab">MIoT Lab</a>, as described above.
				The <a href="#acr-mqttsn">MQTT-SN</a>/<a href="#acr-coap">CoAP</a> server is run on a virtual server that is reachable from the Nucleo boards via the x86 nodes. The connection is established either via Ethernet or via a <a href="#acr-6lowpan">6LoWPAN</a> border router running on one of the Nucleo boards. (We use the example <code>gnrc_border_router</code> provided by RIOT.)
				During the experiments, the CPU and <a href="#acr-ram">RAM</a> usages of the virtual server are logged.</p>

				<p>Both duration and power usage are measured at the same time. The measurements are repeated 30&nbsp;times for each parameter combination.
				The power usage readings are logged by the ESP32 which is connected to two TI~INA3221 current and voltage monitors with three channels each, so they can separately monitor the power usage of the Nucleo board, its transceivers and environmental sensors.
				The monitors are configured to use a conversion time of 140&nbsp;μs for both the shunt and bus voltage and to average 64&nbsp;samples for each reading. New power readings are logged every 860&nbsp;μs.
				The readings as well as the start and end timestamps are captured by a Python program running on the x86 node which receives the log outputs of the Nucleo board and the ESP32 over serial connections.
				To finally calculate the energy consumption, the power readings (in W) are integrated over the time period during which the firmware update was running.
				For the updates run over Ethernet, we use only the power readings of the Nucleo board itself in this calculation. For the updates run over-the-air, we additionally use the power readings of the IEEE&nbsp;802.15.4 transceiver.
				The power readings of the other channels, i.e. the other transceivers and sensors, are discarded since they are not relevant for the firmware update process.</p>

				<h2 id="sec-eval-results"><a href="#sec-eval-results">Results</a></h2>

				<p>In this section, we describe and discuss the results of our evaluation.</p>

				<h3 id="sec-eval-memory">Memory Usage</h3>

				<p>The results of the memory usage analysis are shown in <a href="#tab-eval-memory">Table&nbsp;4</a>.
				Note that the actual <a href="#acr-ram">RAM</a> usages of the two variants could be lower, since we did not optimize the stack sizes but left them at their default values, which may be larger than actually required.</p>

				<p>The direct comparison of the memory usages shows that our implementation of the <a href="#acr-mqttsn">MQTT-SN</a> transport mechanism requires 0.4&nbsp;KiB more flash memory and 1.2&nbsp;KiB more <a href="#acr-ram">RAM</a> than the pre-existing implementation of the <a href="#acr-coap">CoAP</a> transport mechanism.
				The slight increase in flash memory usage is due to a slightly larger code size (+0.17&nbsp;KiB) of the functions required for the <a href="#acr-ota">OTA</a> updates, e.g. the <a href="#acr-mqttsn">MQTT-SN</a> <span class="sc">Publish</span> handlers (see <a href="#sec-implementation-details">Section&nbsp;4.2.2</a>) and the functions required for the usage of thread flags.
				Thread flags are used in our <a href="#acr-mqttsn">MQTT-SN</a> transport mechanism code as well as <code>emcute</code>'s code to communicate events between threads.
				The increase in <a href="#acr-ram">RAM</a> usage is due to <a href="#acr-ram">RAM</a> used by <code>emcute</code>, mainly for the transmit and receive buffers (512&nbsp;B each by default), which are statically allocated in the BSS section.
				In contrast, the transmit buffer (256&nbsp;B by default) and receive buffer (sized according to the requested block size) used by <code>nanocoap</code> are allocated on the stack of the transport mechanism's thread.</p>

				<table id="tab-eval-memory">
					<caption>Flash memory and <a href="#acr-ram">RAM</a> usage of the <a href="#acr-suit">SUIT</a> application using the <a href="#acr-coap">CoAP</a> or the <a href="#acr-mqttsn">MQTT-SN</a> transport mechanism.</caption>
					<thead>
						<tr>
							<td></td>
							<td colspan="3">Flash memory</td>
							<td colspan="3"><a href="#acr-ram">RAM</a></td>
						</tr>
						<tr>
							<td>Component</td>
							<td><a href="#acr-coap">CoAP</a></td>
							<td><a href="#acr-mqttsn">MQTT-SN</a></td>
							<td>Diff.</td>
							<td><a href="#acr-coap">CoAP</a></td>
							<td><a href="#acr-mqttsn">MQTT-SN</a></td>
							<td>Diff.</td>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Core</td>
							<td>28.63&nbsp;KiB</td>
							<td>30.03&nbsp;KiB</td>
							<td>+1.4&nbsp;KiB</td>
							<td>4.6&nbsp;KiB</td>
							<td>4.6&nbsp;KiB</td>
							<td>0</td>
						</tr>
						<tr>
							<td>Network</td>
							<td>29.3&nbsp;KiB</td>
							<td>28.8&nbsp;KiB</td>
							<td>-0.5&nbsp;KiB</td>
							<td>6.194&nbsp;KiB</td>
							<td>6.184&nbsp;KiB</td>
							<td>0</td>
						</tr>
						<tr>
							<td><a href="#acr-coap">CoAP</a>/<a href="#acr-mqttsn">MQTT-SN</a></td>
							<td>2.23&nbsp;KiB</td>
							<td>1.77&nbsp;KiB</td>
							<td>-0.456&nbsp;KiB</td>
							<td>0</td>
							<td>1.224&nbsp;KiB</td>
							<td>+1.22&nbsp;KiB</td>
						</tr>
						<tr>
							<td>Crypto</td>
							<td>6.213&nbsp;KiB</td>
							<td>6.213&nbsp;KiB</td>
							<td>0</td>
							<td>96&nbsp;B</td>
							<td>96&nbsp;B</td>
							<td>0</td>
						</tr>
						<tr>
							<td><a href="#acr-cose">COSE</a> & <a href="#acr-cbor">CBOR</a></td>
							<td>2.08&nbsp;KiB</td>
							<td>1.99&nbsp;KiB</td>
							<td>-0.09&nbsp;KiB</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td><a href="#acr-suit">SUIT</a></td>
							<td>3.05&nbsp;KiB</td>
							<td>3.04&nbsp;KiB</td>
							<td>-0.01&nbsp;KiB</td>
							<td>48&nbsp;B</td>
							<td>48&nbsp;B</td>
							<td>0</td>
						</tr>
						<tr>
							<td><a href="#acr-ota">OTA</a></td>
							<td>2.453&nbsp;KiB</td>
							<td>2.623&nbsp;KiB</td>
							<td>+0.17&nbsp;KiB</td>
							<td>8.4&nbsp;KiB</td>
							<td>8.393&nbsp;KiB</td>
							<td>0</td>
						</tr>
						<tr class="subhead">
							<td>Total</td>
							<td>74&nbsp;KiB</td>
							<td>74.4&nbsp;KiB</td>
							<td>+0.4&nbsp;KiB</td>
							<td>19.34&nbsp;KiB</td>
							<td>20.54&nbsp;KiB</td>
							<td>+1.201&nbsp;KiB</td>
						</tr>
					</tbody>
				</table>

				<p>The Nucleo boards that we use in our testbed are less constrained in terms of flash memory and <a href="#acr-ram">RAM</a> than others, since they are part of STMicroelectronics' “high-performance” product line. This puts them beyond the least constrained class defined by RFC&nbsp;7228&nbsp;<a href="#rfc7228">[12]</a> (Class 2 with ~50&nbsp;KiB <a href="#acr-ram">RAM</a> and ~250&nbsp;KiB flash memory).
				However, it can be seen that our <a href="#acr-mqttsn">MQTT-SN</a> variant can also be run on more constrained devices (up to Class&nbsp;1 with ~10&nbsp;KiB <a href="#acr-ram">RAM</a> and ~100&nbsp;KiB flash memory), same as the pre-existing <a href="#acr-coap">CoAP</a> variant.
				Thus, the implementation fulfils the goal set by the <a href="#acr-suit">SUIT</a> standard to be suitable for Class&nbsp;1 devices.</p>

				<h3 id="sec-eval-traffic">Network Traffic Volume</h3>

				<p>We examine the application layer traffic in <a href="#fig-eval-traffic">Figure&nbsp;9</a>.
				In both cases, the payload sent from the server or broker to the device is equal to the size of the update manifest and firmware image as listed in <a href="#tab-eval-parameters">Table&nbsp;3</a> (approximately 85&nbsp;kB).
				In addition to the payload itself, there is overhead traffic, i.e. protocol headers, <a href="#acr-mqttsn">MQTT-SN</a> topic names and <a href="#acr-coap">CoAP</a> <a href="#acr-uri">URIs</a>.
				As expected, the amount of overhead traffic decreases approximately linearly with the increased block size.</p>
				
				<figure id="fig-eval-traffic" class="has-subfigures">
					<figure>
						<img src="img/fig-eval-traffic-broker-to-device.svg"/>
						<figcaption>Broker/server to device.</figcaption>
					</figure>
					<figure>
						<img src="img/fig-eval-traffic-device-to-broker.svg"/>
						<figcaption>Device to broker/server.</figcaption>
					</figure>
					<figcaption>Network traffic volume of a full firmware update using <a href="#acr-suit">SUIT</a> over <a href="#acr-mqttsn">MQTT-SN</a> or <a href="#acr-coap">CoAP</a>: Only the relevant network traffic caused by the application layer protocols and payloads is shown.</figcaption>
				</figure>

				<p>It can be seen that <a href="#acr-mqttsn">MQTT-SN</a> causes slightly more traffic than <a href="#acr-coap">CoAP</a>.
				The larger the block size, the smaller the difference is.
				For a block size of 32&nbsp;B, the difference in traffic volume between <a href="#acr-mqttsn">MQTT-SN</a> and <a href="#acr-coap">CoAP</a> is the largest: <a href="#acr-mqttsn">MQTT-SN</a> causes 13.2&nbsp;kB and 17.4&nbsp;kB more traffic from broker to device and device to broker, respectively.
				For a block size of 512&nbsp;B, <a href="#acr-mqttsn">MQTT-SN</a> causes only 1.2&nbsp;kB and 1.1&nbsp;kB more traffic from broker to device and device to broker, respectively.
				This is because the sizes of the headers that are sent per block are smaller for <a href="#acr-coap">CoAP</a> than for <a href="#acr-mqttsn">MQTT-SN</a> (see <a href="#tab-header-sizes">Table&nbsp;5</a>).
				As expected, <a href="#acr-mqttsn">MQTT-SN</a> also sends twice as many packets per block as <a href="#acr-coap">CoAP</a> does (see <a href="#tab-eval-traffic-num-packets">Table&nbsp;6</a>). Thus, the amount of traffic caused by lower layer protocol headers  such as IEEE&nbsp;802.15.4 and <a href="#acr-6lowpan">6LoWPAN</a>, which we do not examine here, is doubled.</p>

				<table id="tab-header-sizes">
					<caption>Traffic caused by <a href="#acr-mqttsn">MQTT-SN</a> and <a href="#acr-coap">CoAP</a> headers: Note that the <a href="#acr-coap">CoAP</a> header sizes are specific to the <a href="#acr-coap">CoAP</a> options used here (e.g. number of <a href="#acr-uri">URI</a> path components).</caption>
					<thead>
						<tr>
							<td>Protocol</td>
							<td colspan="2">Direction</td>
						</tr>
						<tr>
							<td></td>
							<td>Client &rarr; server</td>
							<td>Server &rarr; client</td>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><a href="#acr-mqttsn">MQTT-SN</a></td>
							<td>7&nbsp;B (<span class="sc">Subscribe</span>) + 5&nbsp;B (<span class="sc">PubAck</span>) = 12&nbsp;B</td>
							<td>7&nbsp;B (<span class="sc">SubAck</span>) + 7&nbsp;B (<span class="sc">Publish</span>) = 14&nbsp;B</td>
						</tr>
						<tr>
							<td><a href="#acr-coap">CoAP</a></td>
							<td>11&nbsp;B (<span class="sc">Get</span> request)</td>
							<td>9&nbsp;B (<span class="sc">Get</span> response)</td>
						</tr>
					</tbody>
				</table>
				
				<table id="tab-eval-traffic-num-packets">
					<caption>Number of packets sent during a full firmware update over <a href="#acr-mqttsn">MQTT-SN</a> and <a href="#acr-coap">CoAP</a>.</caption>
					<thead>
						<tr>
							<td>Protocol</td>
							<td colspan="5">Block size</td>
						</tr>
						<tr>
							<td></td>
							<td>32&nbsp;B</td>
							<td>64&nbsp;B</td>
							<td>128&nbsp;B</td>
							<td>256&nbsp;B</td>
							<td>512&nbsp;B</td>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><a href="#acr-mqttsn">MQTT-SN</a></td>
							<td>10569</td>
							<td>5293</td>
							<td>2653</td>
							<td>1333</td>
							<td>673</td>
						</tr>
						<tr>
							<td><a href="#acr-coap">CoAP</a></td>
							<td>5282</td>
							<td>2642</td>
							<td>1322</td>
							<td>662</td>
							<td>332</td>
						</tr>
					</tbody>
				</table>

				<h3 id="sec-eval-time">Total Duration of the Firmware Update and Energy Consumption</h3>

				<p>The measured total durations of the firmware updates over Ethernet are shown as boxplots in <a href="#fig-eval-time">Figure&nbsp;10</a>.
				It can be seen that there is little variation between the 30&nbsp;repetitions of each parameter combination.
				Firstly, <a href="#fig-eval-time-mqttsn-single">Figure&nbsp;10a</a> and <a href="#fig-eval-time-coap-single">Figure&nbsp;10b</a> show the results for the firmware update of a single device. The standard deviations are below 1&nbsp;%, except for the combinations (Ethernet,&nbsp;<a href="#acr-mqttsn">MQTT-SN</a>,&nbsp;128&nbsp;B,&nbsp;1&nbsp;device) and (Ethernet,&nbsp;<a href="#acr-coap">CoAP</a>,&nbsp;256&nbsp;B,&nbsp;1&nbsp;device), where there are outliers with significantly increased durations.
				Secondly, <a href="#fig-eval-time-mqttsn-multiple">Figure&nbsp;10c</a> and <a href="#fig-eval-time-coap-multiple">Figure&nbsp;10d</a> show the results for the firmware update of seven devices in parallel.
				Here, the standard deviations of the 30&nbsp;repetitions are slightly larger (up to 4.4&nbsp;%), except for the combination (Ethernet,&nbsp;<a href="#acr-mqttsn">MQTT-SN</a>,&nbsp;64&nbsp;B,&nbsp;7&nbsp;devices), where two outliers were measured.
				The reason for these outliers could not be determined definitively from the experiment logs. As the outliers lie approximately 15&nbsp;s above the other measurements, which is the <a href="#acr-mqttsn">MQTT-SN</a>'s default timeout duration, it can be assumed that they are due to a single lost <a href="#acr-mqttsn">MQTT-SN</a> message.</p>

				<figure id="fig-eval-time" class="has-subfigures">
					<figure id="fig-eval-time-mqttsn-single">
						<img src="img/fig-eval-time-mqttsn-eth-single.svg"/>
						<figcaption><a href="#acr-mqttsn">MQTT-SN</a>, updating a single device</figcaption>
					</figure>
					<figure id="fig-eval-time-coap-single">
						<img src="img/fig-eval-time-coap-eth-single.svg"/>
						<figcaption><a href="#acr-coap">CoAP</a>, updating a single device</figcaption>
					</figure>
					<figure id="fig-eval-time-mqttsn-multiple">
						<img src="img/fig-eval-time-mqttsn-eth-multiple.svg"/>
						<figcaption><a href="#acr-mqttsn">MQTT-SN</a>, updating seven devices in parallel</figcaption>
					</figure>
					<figure id="fig-eval-time-coap-multiple">
						<img src="img/fig-eval-time-coap-eth-multiple.svg"/>
						<figcaption><a href="#acr-coap">CoAP</a>, updating seven devices in parallel</figcaption>
					</figure>
					<figcaption>Duration of a full firmware update over Ethernet using <a href="#acr-mqttsn">MQTT-SN</a> or <a href="#acr-coap">CoAP</a>.</figcaption>
				</figure>

				<p>Comparing the different measurements, it can be seen that, firstly, as expected, the update duration decreases with the block size. The decrease is not fully linear because the larger block sizes do not speed up all steps of the firmware update; e.g. the time required for the validation of manifest and signatures remains the same.
				Secondly, even though a higher total duration could be expected for <a href="#acr-mqttsn">MQTT-SN</a> due to the higher traffic volume (see <a href="#sec-eval-traffic">Section&nbsp;5.3.2</a>), there is no significant difference between the average update durations measured for <a href="#acr-mqttsn">MQTT-SN</a> and <a href="#acr-coap">CoAP</a>.
				Thirdly, when transmitting the updates over Ethernet, there is also no significant difference between the average update durations measured for a single device and seven devices in parallel.</p>

				<p>During the parallel update of seven devices, the total <a href="#acr-ram">RAM</a> usage on the virtual machine running the <a href="#acr-mqttsn">MQTT-SN</a>/<a href="#acr-coap">CoAP</a> server remains at approximately 9&nbsp;%.
				In the CPU usage, there are peaks that coincide with the timings of the firmware updates.
				These peaks go up to 92.4&nbsp;%, but do not last more than 5&nbsp;seconds, i.e. not throughout the entire update transmission. Except during these peaks and during the waiting times between updates, the CPU usage is at 5 to 15&nbsp;%.
				Thus, the server does not appear to act as a performance bottleneck during the parallel update experiments.</p>

				<p>The measured energy consumption during the firmware updates run over Ethernet are shown as boxplots in <a href="#fig-eval-power-usage">Figure&nbsp;11</a>.
				As expected, it can be seen that there is a strong correlation between the measured energy consumption and the measured update duration.
				Thus, the same observations can be made here as for <a href="#fig-eval-time">Figure&nbsp;10</a>: The energy consumption decreases slightly less than linearly with the block size. There is no significant difference between the average energy consumption measured for <a href="#acr-mqttsn">MQTT-SN</a> and <a href="#acr-coap">CoAP</a>.</p>

				<figure id="fig-eval-power-usage" class="has-subfigures">
					<figure id="fig-eval-power-usage-mqttsn-single">
						<img src="img/fig-eval-time-mqttsn-eth-single.svg"/>
						<figcaption><a href="#acr-mqttsn">MQTT-SN</a>, updating a single device</figcaption>
					</figure>
					<figure id="fig-eval-power-usage-coap-single">
						<img src="img/fig-eval-power-usage-coap-eth-single.svg"/>
						<figcaption><a href="#acr-coap">CoAP</a>, updating a single device</figcaption>
					</figure>
					<figure id="fig-eval-power-usage-mqttsn-multiple">
						<img src="img/fig-eval-power-usage-mqttsn-eth-multiple.svg"/>
						<figcaption><a href="#acr-mqttsn">MQTT-SN</a>, updating seven devices in parallel</figcaption>
					</figure>
					<figure id="fig-eval-power-usage-coap-multiple">
						<img src="img/fig-eval-power-usage-coap-eth-multiple.svg"/>
						<figcaption><a href="#acr-coap">CoAP</a>, updating seven devices in parallel</figcaption>
					</figure>
					<figcaption>Energy consumption of the <a href="#acr-iot">IoT</a> board during a full firmware update over <a href="#acr-mqttsn">MQTT-SN</a> and <a href="#acr-coap">CoAP</a>.</figcaption>
				</figure>

				<p>Finally, the duration measurements for the wireless update of a single device (using IEEE&nbsp;802.15.4/<a href="#acr-6lowpan">6LoWPAN</a>) can be seen in <a href="#fig-eval-wireless-time">Figure&nbsp;12</a>.
				In these experiments, testbed node 7 is used as the border router. Testbed node 10 (“TestNode”) is used as the <a href="#acr-suit">SUIT</a> node. Node 10 is positioned in an adjoining room to node 7, i.e. the two nodes are relatively close to each other. Using the 2.4&nbsp;GHz band, the average <a href="#acr-rssi">RSSI</a> between the two nodes is measured to be 77.27&nbsp;dBm.</p>
				
				<figure id="fig-eval-wireless-time" class="has-subfigures">
					<figure id="fig-eval-wireless-time-mqttsn">
						<img src="img/fig-eval-wireless-time-mqttsn.svg"/>
						<figcaption><a href="#acr-mqttsn">MQTT-SN</a>, updating a single device</figcaption>
					</figure>
					<figure id="fig-eval-wireless-time-coap">
						<img src="img/fig-eval-wireless-time-coap.svg"/>
						<figcaption><a href="#acr-coap">CoAP</a>, updating a single device</figcaption>
					</figure>
					<figcaption>Duration of a full firmware update over IEEE&nbsp;802.15.4 using <a href="#acr-mqttsn">MQTT-SN</a> or <a href="#acr-coap">CoAP</a>.</figcaption>
				</figure>

				<p>A complication with the wireless <a href="#acr-mqttsn">MQTT-SN</a> measurements was caused by an unclear point in the protocol specification:
				It states that only messages unicasted to the <a href="#acr-mqttsn">MQTT-SN</a> gateway by a client are retransmitted if no acknowledgment is received before a timeout&nbsp;<a href="#mqtt-sn-1.2">[26,&nbsp;p.&nbsp;25]</a>. There is no retransmission procedure specified for messages unicasted by the gateway to a client, such as the firmware blocks in our case.
				This is likely because the <a href="#acr-mqttsn">MQTT-SN</a> gateway is meant to be used in conjunction with an <a href="#acr-mqtt">MQTT</a> broker, which would handle all retransmissions of unacknowleged messages. Thus, the gateway does not need to retransmit lost messages itself.
				However, the <a href="#acr-rsmb">RSMB</a> server implementation of <a href="#acr-mqttsn">MQTT-SN</a> does not implement a standalone gateway that connects to a separate broker. The <a href="#acr-rsmb">RSMB</a> integrates an <a href="#acr-mqtt">MQTT</a> and <a href="#acr-mqttsn">MQTT-SN</a> broker in the same application. When a client connects to the <a href="#acr-rsmb">RSMB</a> using <a href="#acr-mqttsn">MQTT-SN</a>, there is no connection made internally to the <a href="#acr-mqtt">MQTT</a> broker. Thus, the broker actually does not retransmit any lost messages, since it is not involved in the transaction.
				This means that when a block is lost in transmission, the update fails.
				Additionally, there appears to be a bug in RIOT affecting IEEE&nbsp;802.15.4 retransmissions over the AT86RF215 transceiver: A sniffer trace also showed no such retransmissions in case of a missing acknowledgement. Due to time constraints, this could not be investigated further.</p>

				<p>As expected due to the lower throughput, the wireless updates are slower than the wired updates.
				We compare the average update durations side-by-side in <a href="#tab-eval-wired-wireless-comp">Table&nbsp;7</a>.
				Over <a href="#acr-coap">CoAP</a>, the wireless updates are slower by 153&nbsp;% on average when compared to the wired updates.
				Over <a href="#acr-mqttsn">MQTT-SN</a>, the wireless updates are slower by 506&nbsp;% on average.
				Thus, although there was no significant difference between <a href="#acr-coap">CoAP</a> and <a href="#acr-mqttsn">MQTT-SN</a> when running wired updates, <a href="#acr-mqttsn">MQTT-SN</a> performs much worse than <a href="#acr-coap">CoAP</a> when updating over the air.
				The main reason for this is the much longer default timeout duration for retransmissions of 15&nbsp;s&nbsp;<a href="#mqtt-sn-1.2">[26,&nbsp;p.&nbsp;27]</a>.
				This means that every time an <a href="#acr-mqttsn">MQTT-SN</a> message is lost, the update duration increases by at least 15&nbsp;s.
				Thus, the performance is worst for the smallest block sizes where the most <a href="#acr-mqttsn">MQTT-SN</a> messages are transmitted, each of which can potentially get lost and cause a timeout.
				Additionally, the chance of an update-stopping timeout occurring (after three unsuccessful retransmissions) is higher the smaller the block size is. Due to this, none of 60~repetitions of a wireless update over <a href="#acr-mqttsn">MQTT-SN</a> with a block size of 32&nbsp;B could be completed successfully.
				In contrast, <a href="#acr-coap">CoAP</a> uses exponentially increasing timeout durations with a default starting value of 2 to 3&nbsp;s and thus retransmits much faster.</p>

				<table id="tab-eval-wired-wireless-comp">
					<caption>Average update durations of both wired and wireless updates over <a href="#acr-mqttsn">MQTT-SN</a> and <a href="#acr-coap">CoAP</a>.</caption>
					<thead>
						<tr>
							<td></td>
							<td colspan="3"><a href="#acr-mqttsn">MQTT-SN</a></td>
							<td colspan="3"><a href="#acr-coap">CoAP</a></td>
						</tr>
						<tr>
							<td>Block size</td>
							<td>Wired</td>
							<td>Wireless</td>
							<td>Diff.</td>
							<td>Wired</td>
							<td>Wireless</td>
							<td>Diff.</td>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>32&nbsp;B</td>
							<td>32.65&nbsp;s</td>
							<td>n/a</td>
							<td>n/a</td>
							<td>33.09&nbsp;s</td>
							<td>80.45&nbsp;s</td>
							<td>+143.13&nbsp;%</td>
						</tr>
						<tr>
							<td>64&nbsp;B</td>
							<td>18.88&nbsp;s</td>
							<td>131.6&nbsp;s</td>
							<td>+597.03&nbsp;%</td>
							<td>19.17&nbsp;s</td>
							<td>50.35&nbsp;s</td>
							<td>+162.65&nbsp;%</td>
						</tr>
						<tr>
							<td>128&nbsp;B</td>
							<td>12.48&nbsp;s</td>
							<td>92.88&nbsp;s</td>
							<td>+644.23&nbsp;%</td>
							<td>12.17&nbsp;s</td>
							<td>31.36&nbsp;s</td>
							<td>+157.68&nbsp;%</td>
						</tr>
						<tr>
							<td>256&nbsp;B</td>
							<td>8.55&nbsp;s</td>
							<td>46.43&nbsp;s</td>
							<td>+443.04&nbsp;%</td>
							<td>8.76&nbsp;s</td>
							<td>22.18&nbsp;s</td>
							<td>+153.2&nbsp;%</td>
						<tr>
							<td>512&nbsp;B</td>
							<td>6.84&nbsp;s</td>
							<td>30.15&nbsp;s</td>
							<td>+340.79&nbsp;%</td>
							<td>6.94&nbsp;s</td>
							<td>17.26&nbsp;s</td>
							<td>+148.7&nbsp;%</td>
						</tr>
					</tbody>
				</table>

				<p>The effect of increasing the block size is very similar to the one observed for wired updates:
				A doubling of the block size leads to a decrease of the average update duration of around 33&nbsp;% on average (see <a href="#tab-eval-time-speedup">Table&nbsp;8</a>).
				As discussed previously, the decrease is less than 50&nbsp;% because the increased block size speeds up the transmission of the update, but not other steps, e.g. the validation of manifest and signatures, and writing the update image to flash memory.
				It must be noted that the results also show that the speedup effect decreases with each block size doubling.
				Considering wireless transmission, it can be expected that the speedup effect is smaller because starting from a block size of 64&nbsp;B, the blocks must be fragmented by <a href="#acr-6lowpan">6LoWPAN</a> due to IEEE&nbsp;802.15.4's maximum frame size of 127&nbsp;B. This fragmentation adds additional overhead in terms of computation and traffic.
				Over <a href="#acr-coap">CoAP</a>, it can be seen that the speedup effect of the jump from 32&nbsp;B to 64&nbsp;B is indeed smaller than it is for wired transmission, while the other jumps show a similar speedup as for wired transmission.
				Over <a href="#acr-mqttsn">MQTT-SN</a>, the block size increases show a larger effect for wireless than for wired transmission. This may again be related to the long retransmission timeouts; if there are fewer <a href="#acr-mqttsn">MQTT-SN</a> messages to transmit, a smaller number of retransmission timeouts is likely to occur. Thus, the speedup effect is boosted.</p>
				
				<table id="tab-eval-time-speedup">
					<caption>Effect of block size increases on average update durations of both wired and wireless updates over <a href="#acr-mqttsn">MQTT-SN</a> and <a href="#acr-coap">CoAP</a>.</caption>
					<thead>
						<tr>
							<td></td>
							<td colspan="2"><a href="#acr-mqttsn">MQTT-SN</a></td>
							<td colspan="2"><a href="#acr-coap">CoAP</a></td>
						</tr>
						<tr>
							<td>Block sizes</td>
							<td>Wired</td>
							<td>Wireless</td>
							<td>Wired</td>
							<td>Wireless</td>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>32&nbsp;B &rarr; 64&nbsp;B</td>
							<td>-42.18&nbsp;%</td>
							<td>n/a</td>
							<td>-42.07&nbsp;%</td>
							<td>-37.42&nbsp;%</td>
						</tr>
						<tr>
							<td>64&nbsp;B &rarr; 128&nbsp;B</td>
							<td>-33.9&nbsp;%</td>
							<td>-29.42&nbsp;%</td>
							<td>-36.52&nbsp;%</td>
							<td>-37.72&nbsp;%</td>
						</tr>
						<tr>
							<td>128&nbsp;B &rarr; 256&nbsp;B</td>
							<td>-31.49&nbsp;%</td>
							<td>-50.01&nbsp;%</td>
							<td>-28.02&nbsp;%</td>
							<td>-29.27&nbsp;%</td>
						</tr>
						<tr>
							<td>256&nbsp;B &rarr; 512&nbsp;B</td>
							<td>-20&nbsp;%</td>
							<td>-35.06&nbsp;%</td>
							<td>-20.78&nbsp;%</td>
							<td>-22.18&nbsp;%</td>
						</tr>
					</tbody>
				</table>

				<p>As expected, the energy consumption of a wireless update is also higher than the energy consumption of an update over Ethernet (see <a href="#fig-eval-wireless-power">Figure&nbsp;13</a>). Again, there is a strong correlation between the update duration and energy consumption.</p>
				
				<figure id="fig-eval-wireless-power" class="has-subfigures">
					<figure id="fig-eval-wireless-power-mqttsn">
						<img src="img/fig-eval-wireless-power-mqttsn.svg"/>
						<figcaption><a href="#acr-mqttsn">MQTT-SN</a>, updating a single device</figcaption>
					</figure>
					<figure id="fig-eval-wireless-power-coap">
						<img src="img/fig-eval-wireless-power-coap.svg"/>
						<figcaption><a href="#acr-coap">CoAP</a>, updating a single device</figcaption>
					</figure>
					<figcaption>Energy consumption of the <a href="#acr-iot">IoT</a> board (including transceiver) during a full firmware update over IEEE&nbsp;802.15.4 using <a href="#acr-mqttsn">MQTT-SN</a> or <a href="#acr-coap">CoAP</a>.</figcaption>
				</figure>

				<p>For wireless updates of multiple devices at once, we could conduct only preliminary experiments which showed that the GNRC border router performs badly under load:
				We observed update success rates of less than 50&nbsp;%. In a minimal test setup consisting of one border router and two wireless <a href="#acr-suit">SUIT</a> nodes, updating the nodes one after another was actually significantly faster than updating them in parallel.
				The border router logs showed frequent acknowledgement timeouts as well as sending delays due to a busy channel, which arise from the wireless channel being shared between all updated devices.
				It may be possible to improve the performance of the border router under heavy load by using the <code>gnrc_netif_pktq</code> module, which implements a queue for outgoing packets that could not be transmitted successfully on the first try.
				Additionally, the reliability of parallel over-the-air updates could be increased by using a <a href="#acr-maclayer">MAC</a> protocol based on <a href="#acr-tdma">TDMA</a>, and the shared channel could be better utilized using multicast to efficiently transmit the update to multiple devices at once.</p>

				<h2 id="sec-eval-conclusion"><a href="#sec-eval-conclusion">Conclusion</a></h2>

				<p>In conclusion, the evaluation of our implementation shows that it fulfils the goal that was previously set, i.e. achieving the same or better performance in comparison with the <a href="#acr-coap">CoAP</a> transport mechanism, with the exception of the issues discovered when transmitting updates over the air.</p>

				<p>The evaluation of the memory usage of our implementation shows that it requires only slightly more flash memory (+0.4&nbsp;KiB) and <a href="#acr-ram">RAM</a> (+1.2&nbsp;KiB) than the <a href="#acr-coap">CoAP</a> transport mechanism, mainly due to the code size and the transmit and receive buffers of the <code>emcute</code> library.
				Thus, it is suitable for constrained Class&nbsp;1 devices.</p>

				<p>With regard to network traffic on the application layer and up, our <a href="#acr-mqttsn">MQTT-SN</a> transport mechanism causes slightly more traffic because the <a href="#acr-mqttsn">MQTT-SN</a> headers sent per block are larger than the <a href="#acr-coap">CoAP</a> headers by 6&nbsp;B. Thus, the difference in traffic volume is almost negligible for larger block sizes.
				In our design, where one <a href="#acr-mqttsn">MQTT-SN</a> topic is used per block, <a href="#acr-mqttsn">MQTT-SN</a> sends twice as many packets as <a href="#acr-coap">CoAP</a>, and thus the lower-layer header traffic is also doubled.</p>

				<p>However, the evaluation of the update duration when transmitting over Ethernet shows that our implementation is not slower than the <a href="#acr-coap">CoAP</a> transport mechanism. Both when updating a single device and when updating seven devices in parallel, there is no significant difference between the measured update durations.
				There is also no significant difference between the update durations for updating a single device and updating seven devices in parallel; thus, both transport mechanisms scale very well for up to seven devices.
				Increased block sizes lead to shorter update durations; when doubling the block size, the speedup is around 33&nbsp;% on average.
				However, the speedup effect decreases with each block size doubling, i.e. the update duration begins to plateau after a few doublings.
				The speedup is less than 50&nbsp;% because some parts of the update are not sped up by the increased block size, e.g. signature verification.
				Additionally, the time required to write the update image to flash memory is a lower bound on the update duration.
				For wireless transmission, the added overhead of fragmentation decreases the speedup effect.
				As expected, our evaluation shows that the wireless transmission is slower than the wired transmission. Over <a href="#acr-coap">CoAP</a>, it is slower by 153&nbsp;% on average. Over <a href="#acr-mqttsn">MQTT-SN</a>, some issues were discovered; it is slower by 506&nbsp;% on average. The main issue is missing retransmissions due to an unclear specification and the high default timeout duration of 15&nbsp;s.
				In all cases, the energy consumption is strongly correlated to the update duration.</p>

				<p>Since the evaluation results show no significant difference between <a href="#acr-coap">CoAP</a> and <a href="#acr-mqttsn">MQTT-SN</a> with regard to the duration and energy consumption of a firmware update when the updates are run over a wired connection, the <a href="#acr-mqttsn">MQTT-SN</a> transport mechanism is not inherently less performant than the <a href="#acr-coap">CoAP</a> transport mechanism. However, it does not handle lost messages as well as <a href="#acr-coap">CoAP</a> does, and thus performs worse for wireless transmission. Further work on this issue could improve the performance of the <a href="#acr-mqttsn">MQTT-SN</a> transport mechanism over the air.</p>

				<p>The main advantage of <a href="#acr-mqttsn">MQTT-SN</a> over <a href="#acr-coap">CoAP</a>, which was discussed in <a href="#sec-app-layer-comp">Section&nbsp;2.4</a> and <a href="#sec-rel-work-comp">Section&nbsp;3.1</a> where we compared the protocols generally, remains: It offers better support for sleeping devices because it allows the devices to be in a low-power sleep mode most of the time, during which the broker buffers messages, while <a href="#acr-coap">CoAP</a> requires the devices to be constantly awake (except for radio duty cycling on the <a href="#acr-maclayer">MAC</a> layer) if they want to receive requests.
				Thus, <a href="#acr-mqttsn">MQTT-SN</a> allows a lower power consumption than <a href="#acr-coap">CoAP</a> during the idle times:
				According to the data sheets, the Nucleo board's STM32 microcontroller draws at most 16.5&nbsp;&micro;W&nbsp;<a href="#stm32f767zi">[68, p.&nbsp;125]</a> and the ATF86 transceiver typically draws 0.09&nbsp;&micro;W&nbsp;<a href="#at86rf215">[67, p.&nbsp;203]</a> in their lowest power modes.
				Thus, the low-power modes allow a vastly improved battery life of the <a href="#acr-iot">IoT</a> device.</p>
      </section>

      <section id="chapter6" class="chapter" data-chapter-num="6">
      	<header>
      		<p class="chapter-num"></p>
		      <h1><a href="#chapter6">Conclusion</a></h1>
        </header>
        
        In this chapter, we summarize our results and provide pointers for future works.

				<h2 id="sec-summary">Summary</h2>

				<p>In this work, we investigated the issue of firmware updates for the <a href="#acr-iot">IoT</a>.
				Firstly, we summarized the key features of the some of the most used application layer protocols for the <a href="#acr-iot">IoT</a>: <a href="#acr-coap">CoAP</a>, <a href="#acr-mqtt">MQTT</a> and <a href="#acr-mqttsn">MQTT-SN</a>. We compared the three protocols. The main difference between <a href="#acr-coap">CoAP</a> and the <a href="#acr-mqtt">MQTT</a> protocols is the communication model used: <a href="#acr-coap">CoAP</a> uses a request/response model similar to <a href="#acr-http">HTTP</a>, while <a href="#acr-mqtt">MQTT</a> and <a href="#acr-mqttsn">MQTT-SN</a> use a publish/subscribe model.
				The main advantage of the publish/subscribe model is that all communication occurs via a central broker. This allows <a href="#acr-mqttsn">MQTT-SN</a> to easily support sleeping devices by buffering messages at the broker, which is essential for conserving the limited battery power of <a href="#acr-iot">IoT</a> devices.
				However, the transfer of large files such as firmware updates fits <a href="#acr-coap">CoAP</a>'s request/response model more naturally, especially using block-wise transfer.</p>

				<p>Secondly, we conducted a literature survey of comparative evaluations of the three application layer protocols with regard to their achieved throughputs, energy consumption, traffic overhead and ability to deal with packet loss.
				These evaluations show that <a href="#acr-tcp">TCP</a> – which is used by <a href="#acr-mqtt">MQTT</a> – is not especially suitable for the <a href="#acr-iot">IoT</a> due to the connection setup and teardown overhead and its larger header size, even though its sliding window protocol for retransmissions allows it to deal with packet loss better than the <a href="#acr-udp">UDP</a>-based protocols.
				Only few previous evaluation results are available for <a href="#acr-mqttsn">MQTT-SN</a>, but they suggest that it can perform as well as <a href="#acr-coap">CoAP</a>.</p>

				<p>Thirdly, we defined a list of requirements for software update mechanisms in the context of the <a href="#acr-iot">IoT</a>.
				We surveyed other software update mechanisms besides <a href="#acr-suit">SUIT</a>, such as <a href="#acr-tuf">TUF</a>, Uptane, and UpKit, and analysed their main similarities and differences to <a href="#acr-suit">SUIT</a>.
				A common feature of all surveyed update mechanisms is the usage of cryptographic signatures for authentication and integrity checking of the update images and metadata.
				There are differences in the metadata formats and how exactly the cryptographic signatures are used. For example, UpKit always uses two cryptographic signatures; one by the firmware vendor and one by the update server that binds the update to a random nonce generated by the <a href="#acr-iot">IoT</a> device to prevent replay attacks.
				In contrast, <a href="#acr-suit">SUIT</a> uses only a single signature and uses optional expiration timestamps to prevent the replaying of an outdated update.
				Overall, <a href="#acr-suit">SUIT</a> offers the most general framework for software updates through the command sequences that are included in the update manifests and can flexibly specify the steps of the fetching, validation and installation process according to the use case.</p>

				<p>Finally, we described the design and implementation of a new transport mechanism using <a href="#acr-mqttsn">MQTT-SN</a> for firmware updates over <a href="#acr-suit">SUIT</a> in RIOT.
				Previously, only a transport mechanism using <a href="#acr-coap">CoAP</a> was available.
				We evaluated the implementation firstly with regard to its flash memory and <a href="#acr-ram">RAM</a> requirements and network traffic volume. Our evaluation showed that our new transport mechanism uses a similar amount of flash memory and <a href="#acr-ram">RAM</a> as the <a href="#acr-coap">CoAP</a> transport mechanism. Because of the design choice of using a separate <a href="#acr-mqttsn">MQTT-SN</a> topic for each firmware block, our new transport mechanism causes slightly more network traffic due to application layer header overhead.
				Secondly, we evaluated the implementation in the <a href="#acr-miot-lab">MIoT Lab</a> testbed at the Otto von Guericke University Magdeburg.
				At the time of writing, the testbed consisted of a maximum of seven usable nodes, which we used for scalability tests.
				The testbed experiments showed that over Ethernet, there is no significant difference of update duration and energy consumption between the two transport mechanisms, i.e. <a href="#acr-mqttsn">MQTT-SN</a> performs as well as <a href="#acr-coap">CoAP</a>.
				Thus, the implementation fulfils its main goals.
				However, during over-the-air experiments using IEEE&nbsp;802.15.4/<a href="#acr-6lowpan">6LoWPAN</a>, we discovered some issues with the <a href="#acr-mqttsn">MQTT-SN</a> protocol specification that caused a relatively poor performance of <a href="#acr-mqttsn">MQTT-SN</a>: The specification is unclear on the issue of who is responsible for retransmitting lost messages, and defines a relatively long default retransmission timeout of 10 to 15&nbsp;s.
				Thus, further work is necessary to bring <a href="#acr-mqttsn">MQTT-SN</a>'s performance over wireless connections up to <a href="#acr-coap">CoAP</a>'s level.</p>

				<h2 id="sec-future-work">Future Work</h2>

				<p>To improve upon this work, the performance issues of <a href="#acr-mqttsn">MQTT-SN</a> when wirelessly transmitting updates as described in <a href="#sec-eval-time">Section&nbsp;5.3.3</a> must be further investigated.
				Additionally, the initial scalability experiments for over-the-air updates showed performance issues, which should be investigated and fixed if possible. In particular, the usage of multicast to deliver the update to multiple nodes at once could greatly improve the performance.</p>

				<p>To achieve better performance, some design choices of the <a href="#acr-mqttsn">MQTT-SN</a> transport mechanism could be reconsidered.
				For example, the traffic of <span class="sc">Register</span> messages could be reduced. In the current design, one <span class="sc">Register</span> is sent for each firmware manifest and image block transmitted because each block uses a different topic. Instead, a single topic could be used. This would require the update image and manifest to be published “live” during the update, since retained messages cannot be used. This places additional load on the host which publishes the update files. However, this may be a viable option if it were possible to update a large amount of nodes at once.
				Alternatively, a <a href="#acr-mqttsn">MQTT-SN</a> broker implementation could be extended with a feature similar to <a href="#acr-coap">CoAP</a>'s block-wise transfer.% to transmit large published messages to subscribers in several blocks.</p>

				<p>The scalability measurements presented were limited by the number of available nodes in the testbed, which is seven at the time of writing.
				Once more testbed nodes are rolled out, more extensive scalability experiments could be conducted.</p>

				<p>Finally, future works could build on this work by implementing and evaluating further transport mechanisms using other application layer protocols for the <a href="#acr-iot">IoT</a>.</p>
      </section>
      
      <section id="bibliography">
      	<h1>Bibliography</h1>
      	
      	<dl>
      		<dt id="heise2016ip">[1]</dt>
      		<dd>Ronald Eikenberg. IP-Kameras von Aldi als Sicherheits-GAU. Heise Security, January 2016. <a href="https://www.heise.de/security/meldung/IP-Kameras-von-Aldi-als-Sicherheits-GAU-3069735.html">https://www.heise.de/security/meldung/IP-Kameras-von-Aldi-als-Sicherheits-GAU-3069735.html</a> (last visited on Apr 01, 2021).</dd>

      		<dt id="jsof2020cve11896">[2]</dt>
      		<dd>Moshe Kol and Shlomi Oberman. CVE-2020-11896 RCE and CVE-2020-11898 Info Leak (Ripple20). Technical report, JSOF Research Lab, June 2020. <a href="https://www.jsof-tech.com/jsof_ripple20_technical_whitepaper_june20/">https://www.jsof-tech.com/jsof_ripple20_technical_whitepaper_june20/</a>.</dd>

      		<dt id="cui2013firmware">[3]</dt>
      		<dd>Ang Cui, Michael Costello, and Salvatore Stolfo. When Firmware Mod-
ifications Attack: A Case Study of Embedded Exploitation. 20th Annual Network & Distributed System Security Symposium, February 2013. <a href="https://www.ndss-symposium.org/ndss2013/ndss-2013-programme/when-firmware-modifications-attack-case-study-embedded-exploitation">https://www.ndss-symposium.org/ndss2013/ndss-2013-programme/when-firmware-modifications-attack-case-study-embedded-exploitation</a>.</dd>

      		<dt id="antonakakis2017understanding">[4]</dt>
      		<dd>Manos Antonakakis, Tim April, Michael Bailey, Matt Bernhard, Elie Bursztein, Jaime Cochran, Zakir Durumeric, J. Alex Halderman, Luca Invernizzi, Michalis Kallitsis, Deepak Kumar, Chaz Lever, Zane Ma, Joshua Mason, Damian Menscher, Chad Seaman, Nick Sullivan, Kurt Thomas, and Yi Zhou. Understanding the Mirai Botnet. In 26th {USENIX} security symposium ({USENIX} Security 17), pages 1093–1110, 2017.</dd>

      		<dt id="bsi2020iot">[5]</dt>
      		<dd>Bundesamt für Sicherheit in der Informationstechnik, Bonn, Germany. IT-Grundschutz-Kompendium. SYS.4.4: Allgemeines IoT-Gerät. Reguvis Fachmedien GmbH, February 2020. <a href="https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Grundschutz/Kompendium_Einzel_PDFs/07_SYS_IT_Systeme/SYS_4_4_Allgemeines_IoT_Geraet_Edition_2020.pdf">https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Grundschutz/Kompendium_Einzel_PDFs/07_SYS_IT_Systeme/SYS_4_4_Allgemeines_IoT_Geraet_Edition_2020.pdf</a>.</dd>

      		<dt id="nistir8259a">[6]</dt>
      		<dd>Michael Fagan, Katerina N. Megas, Karen Scarfone, and Matthew Smith. IoT Device Cybersecurity Capability Core Baseline. National Institute of Standards and Technology, Gaithersburg, MD, USA, May 2020. <a href="https://doi.org/10.6028/NIST.IR.8259A">https://doi.org/10.6028/NIST.IR.8259A</a>.</dd>

      		<dt id="eu2019-771">[7]</dt>
      		<dd>Directive (EU) 2019/771 of the European Parliament and of the Council of 20 May 2019 on certain aspects concerning contracts for the sale of goods, amending Regulation (EU) 2017/2394 and Directive 2009/22/EC, and repealing Directive 1999/44/EC. Official Journal of the European Union, 62, May 2019. <a href="https://eur-lex.europa.eu/eli/dir/2019/771/oj">https://eur-lex.europa.eu/eli/dir/2019/771/oj</a>.</dd>

      		<dt id="refe-wkrl">[8]</dt>
      		<dd>Bundesministerium der Justiz und für Verbraucherschutz. Entwurf eines Gesetzes zur Regelung des Verkaufs von Sachen mit digitalen Elementen und anderer Aspekte des Kaufvertrags, December 2020. <a href="https://bmjv.de/SharedDocs/Gesetzgebungsverfahren/DE/Warenkaufrichtlinie.html">https://bmjv.de/SharedDocs/Gesetzgebungsverfahren/DE/Warenkaufrichtlinie.html</a>.</dd>

      		<dt id="schneier2014unpatchable">[9]</dt>
      		<dd>Bruce Schneier. The Internet of Things Is Wildly Insecure – And Often Unpatchable, January 2014. <a href="https://www.schneier.com/essays/archives/2014/01/the_internet_of_thin.html">https://www.schneier.com/essays/archives/2014/01/the_internet_of_thin.html</a> (last visited on Oct 17, 2020).</dd>

      		<dt id="ion2015no">[10]</dt>
      		<dd>Iulia Ion, Rob Reeder, and Sunny Consolvo. “...no one can hack my mind”: Comparing Expert and Non-Expert Security Practices. In Eleventh Symposium On Usable Privacy and Security ({SOUPS} 2015), pages 327–346, 2015.</dd>

      		<dt id="ronen2017iot">[11]</dt>
      		<dd>Eyal Ronen, Adi Shamir, Achi-Or Weingarten, and Colin O’Flynn. IoT Goes Nuclear: Creating a ZigBee Chain Reaction. In 2017 IEEE Symposium on Security and Privacy (SP), pages 195–212. Institute of Electrical and Electronics Engineers (IEEE), 2017. <a href="https://doi.org/10.1109/SP.2017.14">https://doi.org/10.1109/SP.2017.14</a>.</dd>

      		<dt id="rfc7228">[12]</dt>
      		<dd>Carsten Bormann, Mehmet Ersue, and Ari Keränen. Terminology for Constrained-Node Networks. RFC 7228, May 2014. <a href="https://rfc-editor.org/rfc/rfc7228.txt">https://rfc-editor.org/rfc/rfc7228.txt</a>.</dd>

      		<dt id="rfc9019">[13]</dt>
      		<dd>Brendan Moran, Hannes Tschofenig, David Brown, and Milosch Meriac. A Firmware Update Architecture for Internet of Things. RFC 9019, April 2021. <a href="https://rfc-editor.org/rfc/rfc9019.txt">https://rfc-editor.org/rfc/rfc9019.txt</a>.</dd>

      		<dt id="ietf-suit-manifest-12">[14]</dt>
      		<dd>Brendan Moran, Hannes Tschofenig, Henk Birkholz, and Koen Zandberg. A Concise Binary Object Representation (CBOR)-based Serialization Format for the Software Updates for Internet of Things (SUIT) Manifest. Internet-Draft draft-ietf-suit-manifest-12, Internet Engineering Task Force, February 2021. Work in Progress. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-suit-manifest-12">https://datatracker.ietf.org/doc/html/draft-ietf-suit-manifest-12</a>.</dd>

      		<dt id="ietf-suit-information-model-11">[15]</dt>
      		<dd>Brendan Moran, Hannes Tschofenig, and Henk Birkholz. A Manifest Information Model for Firmware Updates in IoT Devices. Internet-Draft draft-ietf-suit-information-model-11, Internet Engineering Task Force, April 2021. Work in Progress. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-suit-information-model-11">https://datatracker.ietf.org/doc/html/draft-ietf-suit-information-model-11</a>.</dd>

      		<dt id="baccelli2012riot">[16]</dt>
      		<dd>Emmanuel Baccelli, Oliver Hahm, Matthias Wählisch, Mesut Gunes, and Thomas Schmidt. RIOT: One OS to Rule Them All in the IoT. [Research Report] RR-8176, INRIA, 2012. <a href="https://hal.inria.fr/hal-00768685v3">https://hal.inria.fr/hal-00768685v3</a>.</dd>

      		<dt id="palattella2012standardized">[17]</dt>
      		<dd>Maria Rita Palattella, Nicola Accettura, Xavier Vilajosana, Thomas Watteyne, Luigi Alfredo Grieco, Gennaro Boggia, and Mischa Dohler. Standardized Protocol Stack for the Internet of (Important) Things. IEEE Communications Surveys & Tutorials, 15(3):1389–1406, 2012. <a href="https://doi.org/10.1109/SURV.2012.111412.00158">https://doi.org/10.1109/SURV.2012.111412.00158</a>.</dd>

      		<dt id="sheng2013survey">[18]</dt>
      		<dd>Zhengguo Sheng, Shusen Yang, Yifan Yu, Athanasios V. Vasilakos, Julie A. Mccann, and Kin K. Leung. A Survey on the IETF Protocol Suite for the Internet of Things: Standards, Challenges, and Opportunities. IEEE Wireless Communications, 20(6):91–98, 2013. <a href="https://doi.org/10.1109/MWC.2013.6704479">https://doi.org/10.1109/MWC.2013.6704479</a>.</dd>

      		<dt id="rfc4944">[19]</dt>
      		<dd>Gabriel Montenegro, Jonathan Hui, David Culler, and Nandakishore Kushalnagar. Transmission of IPv6 Packets over IEEE 802.15.4 Networks. RFC 4944, September 2007. <a href="https://rfc-editor.org/rfc/rfc4944.txt">https://rfc-editor.org/rfc/rfc4944.txt</a>.</dd>

      		<dt id="rfc6282">[20]</dt>
      		<dd>Pascal Thubert and Jonathan Hui. Compression Format for IPv6 Datagrams over IEEE 802.15.4-Based Networks. RFC 6282, September 2011. <a href="https://rfc-editor.org/rfc/rfc6282.txt">https://rfc-editor.org/rfc/rfc6282.txt</a>.</dd>

      		<dt id="rfc7252">[21]</dt>
      		<dd>Zach Shelby, Klaus Hartke, and Carsten Bormann. The Constrained Application Protocol (CoAP). RFC 7252, June 2014. <a href="https://rfc-editor.org/rfc/rfc7252.txt">https://rfc-editor.org/rfc/rfc7252.txt</a>.</dd>

      		<dt id="rfc7540">[22]</dt>
      		<dd>Mike Belshe, Roberto Peon, and Martin Thomson. Hypertext Transfer Protocol Version 2 (HTTP/2). RFC 7540, May 2015. <a href="https://rfc-editor.org/rfc/rfc7540.txt">https://rfc-editor.org/rfc/rfc7540.txt</a>.</dd>

      		<dt id="caceres1994effects">[23]</dt>
      		<dd>Ramon Caceres and Liviu Iftode. The Effects of Mobility on Reliable Transport Protocols. In 14th International Conference on Distributed Computing Systems, pages 12–20. IEEE, 1994. <a href="https://doi.org/10.1109/ICDCS.1994.302385">https://doi.org/10.1109/ICDCS.1994.302385</a>.</dd>

      		<dt id="rfc7959">[24]</dt>
      		<dd>Carsten Bormann and Zach Shelby. Block-Wise Transfers in the Constrained Application Protocol (CoAP). RFC 7959, August 2016. <a href="https://rfc-editor.org/rfc/rfc7959.txt">https://rfc-editor.org/rfc/rfc7959.txt</a>.</dd>

      		<dt id="mqtt-5.0">[25]</dt>
      		<dd>Andrew Banks, Ed Briggs, Ken Borgendale, and Rahul Gupta. MQTT Version 5.0. OASIS Standard, March 2019. <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.pdf">https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.pdf</a>.</dd>

      		<dt id="mqtt-sn-1.2">[26]</dt>
      		<dd>Andy Stanford-Clark and Hong Linh Truong. MQTT For Sensor Networks (MQTT-SN) Protocol Specification (Version 1.2). International Business Machines Corporation (IBM), November 2013. <a href="https://www.oasis-open.org/committees/download.php/66091/MQTT-SN_spec_v1.2.pdf">https://www.oasis-open.org/committees/download.php/66091/MQTT-SN_spec_v1.2.pdf</a>.</dd>

      		<dt id="ietf-core-coap-pubsub-09">[27]</dt>
      		<dd>Michael Koster, Ari Keränen, and Jaime Jimenez. Publish-Subscribe Broker for the Constrained Application Protocol (CoAP). Internet-Draft draft-ietf-core-coap-pubsub-09, Internet Engineering Task Force, September 2019. Work in Progress. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-core-coap-pubsub-09">https://datatracker.ietf.org/doc/html/draft-ietf-core-coap-pubsub-09</a>.</dd>

      		<dt id="iot-developer-survey-2018">[28]</dt>
      		<dd>Eclipse IoT Working Group, AGILE IoT, Institute of Electrical and Electronics Engineers, and Open Mobile Alliance. IoT Developer Survey Results, April 2018. <a href="https://iot.eclipse.org/community/resources/iot-surveys/assets/iot-developer-survey-2018.pdf">https://iot.eclipse.org/community/resources/iot-surveys/assets/iot-developer-survey-2018.pdf</a> (last visited on Feb 19, 2021).</dd>

      		<dt id="dizdarevic2019survey">[29]</dt>
      		<dd>Jasenka Dizdarević, Francisco Carpio, Admela Jukan, and Xavi Masip-Bruin. A Survey of Communication Protocols for Internet of Things and Related Challenges of Fog and Cloud Computing Integration. ACM Computing Surveys (CSUR), 51(6):1–29, 2019. <a href="https://doi.org/10.1145/3292674">https://doi.org/10.1145/3292674</a>.</dd>

      		<dt id="iglesias2017analysis">[30]</dt>
      		<dd>Markel Iglesias-Urkia, Adrián Orive, and Aitor Urbieta. Analysis of CoAP Implementations for Industrial Internet of Things: A Survey. Procedia Computer Science, 109:188–195, 2017. <a href="https://doi.org/10.1016/j.procs.2017.05.323">https://doi.org/10.1016/j.procs.2017.05.323</a>.</dd>

      		<dt id="thantharate2019coap">[31]</dt>
      		<dd>Anurag Thantharate, Cory Beard, and Poonam Kankariya. CoAP and MQTT Based Models to Deliver Software and Security Updates to IoT Devices over the Air. In 2019 International Conference on Internet of Things (iThings) and IEEE Green Computing and Communications (GreenCom) and IEEE Cyber, Physical and Social Computing (CPSCom) and IEEE Smart Data (SmartData), pages 1065–1070. IEEE, 2019. <a href="https://doi.org/10.1109/iThings/GreenCom/CPSCom/SmartData.2019.00183">https://doi.org/10.1109/iThings/GreenCom/CPSCom/SmartData.2019.00183</a>.</dd>

      		<dt id="bideh2020energy">[32]</dt>
      		<dd>Pegah Nikbakht Bideh, Jonathan Sönnerup, and Martin Hell. Energy Consumption for Securing Lightweight IoT Protocols. In Proceedings of the 10th International Conference on the Internet of Things, pages 1–8, 2020. <a href="https://doi.org/10.1145/3410992.3411008">https://doi.org/10.1145/3410992.3411008</a>.</dd>

      		<dt id="collina2014internet">[33]</dt>
      		<dd>Matteo Collina, Marco Bartolucci, Alessandro Vanelli-Coralli, and Giovanni Emanuale Corazza. Internet of Things Application Layer Protocol Analysis over Error and Delay Prone Links. In 2014 7th Advanced Satellite Multimedia Systems Conference and the 13th Signal Processing for Space Communications Workshop (ASMS/SPSC), pages 398–404. IEEE, 2014. <a href="https://doi.org/10.1109/ASMS-SPSC.2014.6934573">https://doi.org/10.1109/ASMS-SPSC.2014.6934573</a>.</dd>

      		<dt id="mun2016assessment">[34]</dt>
      		<dd>Dae-Hyeok Mun, Minh Le Dinh, and Young-Woo Kwon. An Assessment of Internet of Things Protocols for Resource-Constrained Applications. In 2016 IEEE 40th Annual Computer Software and Applications Conference (COMPSAC), volume 1, pages 555–560. IEEE, 2016. <a href="https://doi.org/10.1109/COMPSAC.2016.51">https://doi.org/10.1109/COMPSAC.2016.51</a>.</dd>

      		<dt id="mijovic2016comparing">[35]</dt>
      		<dd>Stefan Mijovic, Erion Shehu, and Chiara Buratti. Comparing Application Layer Protocols for the Internet of Things via Experimentation. In 2016 IEEE 2nd International Forum on Research and Technologies for Society and Industry Leveraging a better tomorrow (RTSI), pages 1–5. IEEE, 2016. <a href="https://doi.org/10.1109/RTSI.2016.7740559">https://doi.org/10.1109/RTSI.2016.7740559</a>.</dd>

      		<dt id="larmo2018comparison">[36]</dt>
      		<dd>Anna Larmo, Felipe Del Carpio, Pontus Arvidson, and Roman Chirikov. Comparison of CoAP and MQTT Performance Over Capillary Radios. In 2018 Global Internet of Things Summit (GIoTS), pages 1–6, 2018. <a href="https://doi.org/10.1109/GIOTS.2018.8534576">https://doi.org/10.1109/GIOTS.2018.8534576</a>.</dd>

      		<dt id="gundogan2018ndn">[37]</dt>
      		<dd>Cenk Gündoğan, Peter Kietzmann, Martine Lenders, Hauke Petersen, Thomas C Schmidt, and Matthias Wählisch. NDN, CoAP, and MQTT: A Comparative Measurement Study in the IoT. In Proceedings of the 5th ACM Conference on Information-Centric Networking, pages 159–171, 2018. <a href="https://doi.org/10.1145/3267955.3267967">https://doi.org/10.1145/3267955.3267967</a>.</dd>

      		<dt id="adjih2015fit">[38]</dt>
      		<dd>Cédric Adjih, Emmanuel Baccelli, Eric Fleury, Gaetan Harter, Nathalie Mitton, Thomas Noel, Roger Pissard-Gibollet, Frédéric Saint-Marcel, Guillaume Schreiner, Julien Vandaele, and Thomas Watteyne. FIT IoT-LAB: A Large Scale Open Experimental IoT Testbed. Milan, Italy, December 2015. <a href="https://hal.inria.fr/hal01213938">https://hal.inria.fr/hal01213938</a>.</dd>

      		<dt id="chen2016performance">[39]</dt>
      		<dd>Yuang Chen and Thomas Kunz. Performance Evaluation of IoT Protocols under a Constrained Wireless Access Network. In 2016 International Conference on Selected Topics in Mobile & Wireless Networking (MoWNeT), pages 1–7. IEEE, 2016. <a href="https://doi.org/10.1109/MoWNet.2016.7496622">https://doi.org/10.1109/MoWNet.2016.7496622</a>.</dd>

      		<dt id="padilla2016future">[40]</dt>
      		<dd>Francisco Javier Acosta Padilla, Emmanuel Baccelli, Thomas Eichinger, and Kaspar Schleiser. The Future of IoT Software Must be Updated. IAB Workshop on Internet of Things Software Update (IoTSU), June 2016.</dd>

      		<dt id="levy2017multiprogramming">[41]</dt>
      		<dd>Amit Levy, Bradford Campbell, Branden Ghena, Daniel B. Giffin, Pat Pannuto, Prabal Dutta, and Philip Levis. Multiprogramming a 64kB Computer Safely and Efficiently. In Proceedings of the 26th Symposium on Operating Systems Principles, SOSP ’17, pages 234–251. Association for Computing Machinery, 2017. <a href="https://doi.org/10.1145/3132747.3132786">https://doi.org/10.1145/3132747.3132786</a>.</dd>

      		<dt id="bauwens2020over">[42]</dt>
      		<dd>Jan Bauwens, Peter Ruckebusch, Spilios Giannoulis, Ingrid Moerman, and Eli De Poorter. Over-the-Air Software Updates in the Internet of Things: An Overview of Key Principles. IEEE Communications Magazine, 58(2):35–41, 2020. <a href="https://doi.org/10.1109/MCOM.001.1900125">https://doi.org/10.1109/MCOM.001.1900125</a>.</dd>

      		<dt id="mottola2008figaro">[43]</dt>
      		<dd>Luca Mottola, Gian Pietro Picco, and Adil Amjad Sheikh. FiGaRo: Fine-Grained Software Reconfiguration for Wireless Sensor Networks. In European Conference on Wireless Sensor Networks, pages 286–304. Springer, 2008.</dd>

      		<dt id="iso27000">[44]</dt>
      		<dd>International Organization for Standardization. ISO/IEC 27000:2018 – Information technology – Security techniques – Information security management systems – Overview and vocabulary, February 2018. <a href="https://standards.iso.org/ittf/PubliclyAvailableStandards/c073906_ISO_IEC_27000_2018_E.zip">https://standards.iso.org/ittf/PubliclyAvailableStandards/c073906_ISO_IEC_27000_2018_E.zip</a>.</dd>

      		<dt id="frisch2017ota">[45]</dt>
      		<dd>Dustin Frisch, Sven Reißmann, and Christian Pape. An Over the Air Update Mechanism for ESP8266 Microcontrollers. ICSNC 2017: The Twelfth International Conference on Systems and Networks Communications, 2017.</dd>

      		<dt id="rfc8240">[46]</dt>
      		<dd>Hannes Tschofenig and Stephen Farrell. Report from the Internet of Things Software Update (IoTSU) Workshop 2016. RFC 8240, September 2017. <a href="https://rfc-editor.org/rfc/rfc8240.txt">https://rfc-editor.org/rfc/rfc8240.txt</a>.</dd>

      		<dt id="zandberg2019secure">[47]</dt>
      		<dd>Koen Zandberg, Kaspar Schleiser, Francisco Acosta, Hannes Tschofenig, and Emmanuel Baccelli. Secure Firmware Updates for Constrained IoT Devices Using Open Standards: A Reality Check. IEEE Access, 7:71907–71920, 2019. <a href="https://doi.org/10.1109/ACCESS.2019.2919760">https://doi.org/10.1109/ACCESS.2019.2919760</a>.</dd>

      		<dt id="klint2016nest">[48]</dt>
      		<dd>Klint Finley. Nest’s Hub Shutdown Proves You’re Crazy to Buy Into the Internet of Things, May 2016. <a href="https://www.wired.com/2016/04/nests-hub-shutdown-proves-youre-crazy-buy-internet-things/">https://www.wired.com/2016/04/nests-hub-shutdown-proves-youre-crazy-buy-internet-things/</a> (last visited on Mar 03, 2021).</dd>

      		<dt id="samuel2010survivable">[49]</dt>
      		<dd>Justin Samuel, Nick Mathewson, Justin Cappos, and Roger Dingledine. Survivable Key Compromise in Software Update Systems. In Proceedings of the 17th ACM Conference on Computer and Communications Security, pages 61–72, 2010. <a href="https://doi.org/10.1145/1866307.1866315">https://doi.org/10.1145/1866307.1866315</a>.</dd>

      		<dt id="cappos2008look">[50]</dt>
      		<dd>Justin Cappos, Justin Samuel, Scott Baker, and John H. Hartman. A Look in the Mirror: Attacks on Package Managers. In Proceedings of the 15th ACM Conference on Computer and Communications Security, pages 565–574, 2008. <a href="https://doi.org/10.1145/1455770.1455841">https://doi.org/10.1145/1455770.1455841</a>.</dd>

      		<dt id="bellissimo2006secure">[51]</dt>
      		<dd>Anthony Bellissimo, John Burgess, and Kevin Fu. Secure Software Updates: Disappointments and New Challenges. In HotSec ’06: 1st USENIX Workshop on Hot Topics in Security, 2006.</dd>

      		<dt id="karthik2016uptane">[52]</dt>
      		<dd>Trishank Karthik, Akan Brown, Sebastien Awwad, Damon McCoy, Russ Bielawski, Cameron Mott, Sam Lauzon, André Weimerskirch, and Justin Cappos. Uptane: Securing Software Updates for Automobiles. In International Conference on Embedded Security in Car, pages 1–11, 2016.</dd>

      		<dt id="langiu2019upkit">[53]</dt>
      		<dd>Antonio Langiu, Carlo Alberto Boano, Markus Schuß, and Kay Römer. UpKit: An Open-Source, Portable, and Lightweight Update Framework for Constrained IoT Devices. 39th IEEE International Conference on Distributed Computing Systems (ICDCS), July 2019.</dd>

      		<dt id="itani2009petra">[54]</dt>
      		<dd>Wassim Itani, Ayman Kayssi, and Ali Chehab. PETRA: A Secure and Energy-Efficient Software Update Protocol for Severely-Constrained Network Devices. In Q2SWinet ’09: Proceedings of the 5th ACM Symposium on QoS and Security for Wireless and Mobile Networks, pages 37–43, October 2009. <a href="https://doi.org/10.1145/1641944.1641952">https://doi.org/10.1145/1641944.1641952</a>.</dd>

      		<dt id="doctorow2015philips">[55]</dt>
      		<dd>Cory Doctorow. Philips Pushes Lightbulb Firmware Update That Locks Out Third-Party Bulbs, December 2015. <a href="https://boingboing.net/2015/12/14/philips-pushes-lightbulb-firmw.html">https://boingboing.net/2015/12/14/philips-pushes-lightbulb-firmw.html</a> (last visited on Mar 10, 2021).</dd>

      		<dt id="doctorow2016hp">[56]</dt>
      		<dd>Cory Doctorow. HP Detonates Its Timebomb: Printers Stop Accepting Third Party Ink En Masse, September 2016. <a href="https://boingboing.net/2016/09/19/hp-detonates-its-timebomb-pri.html">https://boingboing.net/2016/09/19/hp-detonates-its-timebomb-pri.html</a> (last visited on Mar 10, 2021).</dd>

      		<dt id="carman2017smart">[57]</dt>
      		<dd>Ashley Carman. Smart Lock Vendor Accidentally Bricks Its Own Locks Through Firmware Update, August 2017. <a href="https://www.theverge.com/circuitbreaker/2017/8/15/16151798/lockstate-6i-software-update-break-lock">https://www.theverge.com/circuitbreaker/2017/8/15/16151798/lockstate-6i-software-update-break-lock</a> (last visited on Mar 10, 2021).</dd>

      		<dt id="baccelli2018riot">[58]</dt>
      		<dd>Emmanuel Baccelli, Cenk Gündoğan, Oliver Hahm, Peter Kietzmann, Martine S Lenders, Hauke Petersen, Kaspar Schleiser, Thomas C Schmidt, and Matthias Wählisch. RIOT: An Open Source Operating System for Low-End Embedded Devices in the IoT. IEEE Internet of Things Journal, 5(6):4428–4440, 2018. <a href="https://doi.org/10.1109/jiot.2018.2815038">https://doi.org/10.1109/jiot.2018.2815038</a>.</dd>

      		<dt id="ietf-suit-manifest-09">[59]</dt>
      		<dd>Brendan Moran, Hannes Tschofenig, Henk Birkholz, and Koen Zandberg. A Concise Binary Object Representation (CBOR)-based Serialization Format for the Software Updates for Internet of Things (SUIT) Manifest. Internet-Draft draft-ietf-suit-manifest-09, Internet Engineering Task Force, July 2020. Work in Progress. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-suit-manifest-09">https://datatracker.ietf.org/doc/html/draft-ietf-suit-manifest-09</a>.</dd>

      		<dt id="rfc7049">[60]</dt>
      		<dd>Carsten Bormann and Paul E. Hoffman. Concise Binary Object Representation (CBOR). RFC 7049, October 2013. <a href="https://rfc-editor.org/rfc/rfc7049.txt">https://rfc-editor.org/rfc/rfc7049.txt</a>.</dd>

      		<dt id="rfc8152">[61]</dt>
      		<dd>Jim Schaad. CBOR Object Signing and Encryption (COSE). RFC 8152, July 2017. <a href="https://rfc-editor.org/rfc/rfc8152.txt">https://rfc-editor.org/rfc/rfc8152.txt</a>.</dd>

      		<dt id="2020tuf">[62]</dt>
      		<dd>The Update Framework Specification (Version: 1.0.17), December 2020. <a href="https://github.com/theupdateframework/specification/blob/9d21a28ff143d323014c92c32f235383f3d3f5b6/tuf-spec.md">https://github.com/theupdateframework/specification/blob/9d21a28ff143d323014c92c32f235383f3d3f5b6/tuf-spec.md</a>.</dd>

      		<dt id="asokan2018assured">[63]</dt>
      		<dd>N. Asokan, Thomas Nyman, Norrathep Rattanavipanon, Ahmad-Reza Sadeghi, and Gene Tsudik. ASSURED: Architecture for Secure Software Update of Realistic Embedded Devices. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 37(11), November 2018.</dd>

      		<dt id="rfc4086">[64]</dt>
      		<dd>Donald E. Eastlake 3rd, Steve Crocker, and Jeffrey I. Schiller. Randomness Requirements for Security. RFC 4086, June 2005. <a href="https://rfc-editor.org/rfc/rfc4086.txt">https://rfc-editor.org/rfc/rfc4086.txt</a>.</dd>

      		<dt id="schmidt2019how">[65]</dt>
      		<dd>Silvie Schmidt, Mathias Tausig, Manuel Koschuch, Matthias Hudler, Georg Simhandl, Patrick Puddu, and Zoran Stojkovic. How Little is Enough? Implementation and Evaluation of a Lightweight Secure Firmware Update Process for the Internet of Things. Proceedings of the 3rd International Conference on Internet of Things, Big Data and Security (IoTBDS 2018), pages 63–72, 2019.</dd>

      		<dt id="kientopf2019miot">[66]</dt>
      		<dd>Kai Kientopf, Marian Buschsieweke, and Mesut Güneş. Technical Report: Designing a Testbed for Wireless Communication Research on Embedded Devices. In 18. GI/ITG KuVS FachGespräch SensorNetze (FGSN 2019), pages 41–44, 2019.</dd>

      		<dt id="at86rf215">[67]</dt>
      		<dd>Atmel Corporation. Atmel AT86RF215 Datasheet (Revision 42415E), May 2016. <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42415-WIRELESS-AT86RF215_Datasheet.pdf">https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42415-WIRELESS-AT86RF215_Datasheet.pdf</a> (last visited on Jun 01, 2021).</dd>

      		<dt id="stm32f767zi">[68]</dt>
      		<dd>STMicroelectronics. STM32F765xx STM32F767xx STM32F768Ax STM32F769xx Datasheet (Revision 7), February 2021. <a href="https://www.st.com/resource/en/datasheet/stm32f767zi.pdf">https://www.st.com/resource/en/datasheet/stm32f767zi.pdf</a> (last visited on Jun 01, 2021).</dd>

    		</dl>
      </section>

      <section id="appendix1" class="appendix" data-appendix-num="1">
      	<header>
      		<p class="appendix-num"></p>
		      <h1><a href="#appendix1">List of Software Versions Used</a></h1>
        </header>
        
        <table>
        	<thead>
        		<tr>
        			<td>Name and Description</td>
        			<td>Version</td>
        		</tr>
        	</thead>
        	<tbody>
        		<tr class="subhead">
        			<td colspan="2">Main software</td>
        		</tr>
        		<tr>
        			<td><code>aiocoap</code> (Python <a href="#acr-coap">CoAP</a> implementation)</td>
        			<td>0.4.1</td>
        		</tr>
        		<tr>
        			<td><code>libcoap</code> (C <a href="#acr-coap">CoAP</a> implementation)</td>
        			<td>4.2.1</td>
        		</tr>
        		<tr>
        			<td>RIOT (<a href="#acr-os">OS</a> for <a href="#acr-iot">IoT</a> devices)</td>
        			<td><a href="https://github.com/RIOT-OS/RIOT">GitHub repository</a> at commit <code>837b55f</code> (Feb 1, 2021)</td>
        		</tr>
        		<tr>
        			<td><a href="#acr-rsmb">RSMB</a> (<a href="#acr-mqtt">MQTT</a>/<a href="#acr-mqttsn">MQTT-SN</a> broker)</td>
        			<td><a href="https://github.com/eclipse/mosquitto.rsmb">GitHub repository</a> at commit <code>36fd4ba</code> (Dec 21, 2020) + cherry-picked commit <code>6fed013</code> from <a href="https://github.com/eclipse/mosquitto.rsmb/pull/32">PR&nbsp;32</a></td>
        		</tr>
        		<tr class="subhead">
        			<td colspan="2">Development</td>
        		</tr>
        		<tr>
        			<td>Docker (Virtualisation tool)</td>
        			<td>19.03.8</td>
        		</tr>
        		<tr>
        			<td><code>riot/riotbuild</code> (Docker image for building RIOT applications</td>
        			<td><code>sha256-0673aacb9dfd9b0a00f7695b60dbbc0ce48437e9fc354904fde92611dea9fde2</code></td>
        		</tr>
        		<tr class="subhead">
        			<td colspan="2">Evaluation</td>
        		</tr>
        		<tr>
        			<td>Bloaty (Size profiler for binary files)</td>
        			<td><a href="https://github.com/google/bloaty">GitHub repository</a> at commit <code>c41086c</code> (Nov 19, 2020)</td>
        		</tr>
        		<tr>
        			<td>PyShark (Python wrapper for Wireshark)</td>
        			<td>0.4.3</td>
        		</tr>
        		<tr>
        			<td>Python</td>
        			<td>3.8.5 (locally + testbed server), 3.7.3 (testbed nodes)</td>
        		</tr>
        		<tr>
        			<td>Wireshark (Network traffic capture and analysis tool)</td>
        			<td>3.4.2-1&nbsp;ubuntu20.04.0+wiresharkdevstable1</td>
        		</tr>
        	</tbody>
        </table>
      </section>

      <section id="appendix2" class="appendix" data-appendix-num="2">
      	<header>
      		<p class="appendix-num"></p>
		      <h1><a href="#appendix2">List of Reported Issues and Pull Requests Related to This Thesis</a></h1>
        </header>
        
        <h2>Issues</h2>
        
        <table>
        	<thead>
        		<tr>
        			<td>Description</td>
        			<td>Link</td>
        			<td>Reported on</td>
        			<td>Status</td>
        		</tr>
        	</thead>
        	<tbody>
        		<tr class="subhead">
        			<td colspan="4">Paho <a href="#acr-mqttsn">MQTT-SN</a> Gateway</td>
        		</tr>
        		<tr>
        			<td>Gateway assigns non-zero topic ID for wildcard topics</td>
        			<td><a href="https://github.com/eclipse/paho.mqtt-sn.embedded-c/issues/221">Issue&nbsp;221</a></td>
        			<td>Dec 9, 2020</td>
        			<td>Fixed on May 13, 2021</td>
        		</tr>
        		<tr>
        			<td>Crash (segmentation fault) on PUBLISH when <code>MAX_TOPIC_PAR_CLIENT</code> is exceeded</td>
        			<td><a href="https://github.com/eclipse/paho.mqtt-sn.embedded-c/issues/225">Issue&nbsp;225</a></td>
        			<td>Jan 18, 2021</td>
        			<td>Fixed on May 13, 2021</td>
        		</tr>
        		<tr>
        			<td>Crash (segmentation fault) when <code>getaddrinfo</code> fails</td>
        			<td><a href="https://github.com/eclipse/paho.mqtt-sn.embedded-c/issues/229">Issue&nbsp;229</a></td>
        			<td>Feb 4, 2021</td>
        			<td>Fixed on May 12, 2021</td>
        		</tr>
        		<tr>
        			<td>Gateway sends <span class="sc">Publish</span> using topic ID for which the <span class="sc">Registerlish</span> was rejected</td>
        			<td><a href="https://github.com/eclipse/paho.mqtt-sn.embedded-c/issues/230">Issue&nbsp;230</a></td>
        			<td>Feb 4, 2021</td>
        			<td>Fixed on May 13, 2021</td>
        		</tr>
        	</tbody>
        </table>

				<h2>Pull Requests</h2>
				
				<table>
					<thead>
						<tr>
							<td>Description</td>
							<td>Link</td>
							<td>Submitted on</td>
							<td>Status</td>
						</tr>
					</thead>
					<tbody>
						<tr class="subhead">
							<td colspan="4">RIOT</td>
						</tr>
						<tr>
							<td><code>net/emcute</code>: Allow <span class="sc">Retain</span> flag to be set on incoming <span class="sc">Publish</span>s</td>
							<td><a href="https://github.com/RIOT-OS/RIOT/pull/16326">PR&nbsp;16326</a></td>
							<td>Apr 13, 2021</td>
							<td>Merged on Jun 28, 2021</td>
						</tr>
        		<tr class="subhead">
        			<td colspan="4">Paho <a href="#acr-mqttsn">MQTT-SN</a> Gateway</td>
        		</tr>
        		<tr>
        			<td>Send <span class="sc">Disconnect</span> when incoming message can't be mapped to a client</td>
        			<td><a href="https://github.com/eclipse/paho.mqtt-sn.embedded-c/pull/222">PR&nbsp;222</a></td>
        			<td>Dec 11, 2020</td>
        			<td>Closed on May 27, 2021</td>
        		</tr>
        		<tr class="subhead">
        			<td colspan="4">mqtt-sn-tools</td>
        		</tr>
        		<tr>
        			<td>Bugfix: Use msg ID 0 for QoS levels &lt; 1</td>
        			<td><a href="https://github.com/njh/mqtt-sn-tools/pull/46">PR&nbsp;46</a></td>
        			<td>Dec 4, 2020</td>
        			<td>Merged on Jan 15, 2021</td>
        		</tr>
        	<tbody>
        </table>
      </section>
    </main>
  </body>
</html>
